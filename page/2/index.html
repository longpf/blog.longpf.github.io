<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.32.1" />

  <title>long·pf</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="http://blog.longpengfei.com/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="http://blog.longpengfei.com/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="http://blog.longpengfei.com/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="http://blog.longpengfei.com/img/favicon.ico" type="image/x-icon" />

  
    <link rel="stylesheet" href="http://blog.longpengfei.com/css/my.css">
  
  
    <script src="http://blog.longpengfei.com/js/my.js"></script>
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="http://blog.longpengfei.com/">long·pf</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blog.longpengfei.com/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blog.longpengfei.com/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blog.longpengfei.com/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blog.longpengfei.com/leetcode/"><i class='fa fa-codiepie fa-fw'></i>Leetcode</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blog.longpengfei.com/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">


    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://twitter.com/longpengfei" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://facebook.com/longpengfei" target="_blank"><i class="fa fa-facebook-square fa-fw"></i>Facebook</a>
    </li>
    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://weibo.com/2748226843" target="_blank"><i class="fa fa-weibo fa-fw"></i>Weibo</a>
    </li>
    

    

    


    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/longpf" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2018. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>long·pf</h1>
  <h2>do your good at,challenge what do you want to do</h2>
</div>

<div class="content">
  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/30-substring-with-concatenation-of-all-words-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/">30. Substring With Concatenation of All Words 串联所有单词的子串</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>08 Feb 2018, 16:33</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/hash-table">Hash Table</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/two-pointers">Two Pointers</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/string">String</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
For example, given:
s: &quot;barfoothefoobarman&quot;
words: [&quot;foo&quot;, &quot;bar&quot;]
You should return the indices: [0,9].
(order does not matter).
Difficulty: Hard
这道题让我们求串联所有单词的子串.所有单词来自输入的数组.所有单词的长度一样,串联的顺序不一定.如题中的例子,可以串联成foobar, barfoo. 这里我们用两个哈希表,一个用来存输入单词数组的每个单词和其的出现次数.然后遍历输入的字符串.设单词的个数为n,每个单词长度为m.每次遍历检查母字符串从该位置开始,每m截取一下查看在第一个哈希表是否存在.如果存在,存入第二个哈希表.如果n个次截取都匹配则这次遍历是符合要求的,存一下结果.
解法1 就是上面分析
class Solution { public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) { vector&lt;int&gt;res; if (s.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/30-substring-with-concatenation-of-all-words-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/29-divide-two-integers-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/">29. Divide Two Integers 两数相除</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>07 Feb 2018, 16:45</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/math">Math</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/binary-search">Binary Search</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT.
Difficulty: Medium
这道题让我们求两个数相除A/B,并且不让使用乘法,除法,取余运算.这样我们只能优先想到位运算和加减法了. 假设A&gt;B,最容易想到的是把A-B赋值给A,并且结果+1,然后再把A-B赋值给A,结果+1.这样一直下去.不过如果是2147483647/1这种情况不会不会通过OJ,因为效率太低,会提示Time Limit Exceeded,不可行.回头想想上面的位运算还没用到,如果A&gt;2*B那么结果是不是加2,如果A&gt;2*2*2B结果是不是加2*2.定义t为除数,p为结果的计数m为被除数的绝对值,n为除数的绝对值.例如100/2
   t
(除数) p
(计数) res
(结果) m
(被除数) t
(除数) p
(计数) res
(结果) m
(被除数) t
(除数) p
(计数) res
(结果) m
(被除数)     2 1 32 36 2 1 48 4 2 1 50 0   4 2   4 2   4 2     8 4   8 4         16 8   16 8         32 16   32 16         64 32              解法1 class Solution { public: int divide(int dividend, int divisor) { if (divisor==0||(dividend==INT_MIN&amp;&amp;divisor==-1)) return INT_MAX; int sign = ((dividend&lt;0)^(divisor&lt;0))?
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/29-divide-two-integers-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/28-implement-strstr-%E5%AE%9E%E7%8E%B0strstr%E5%87%BD%E6%95%B0/">28. Implement strStr() 实现strStr()函数</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>06 Feb 2018, 11:37</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/two-pointers">Two Pointers</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/string">String</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Implement strStr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot; Output: 2  Example 2:
Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; Output: -1  Difficulty: Easy
这道题让我们找出字符串中某个子字符串第一次出现的index.如果子字符串的长度为0,则返回0,如果子字符传的长度大于母字符串,则返回-1.遍历字符串的时候只需要遍历到剩下的长度等于字符串的位置即可.
class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; int m = haystack.size(),n=needle.size(); if (m&lt;n) return -1; for (int i=0;i&lt;=m-n;++i) { int j=0; for (j=0;j&lt;n;j++) if (haystack[i+j]!
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/28-implement-strstr-%E5%AE%9E%E7%8E%B0strstr%E5%87%BD%E6%95%B0/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/27-remove-element-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">27. Remove Element 移除元素</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>06 Feb 2018, 10:46</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/array">Array</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/two-pointers">Two Pointers</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Given an array and a value, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&rsquo;t matter what you leave beyond the new length.
Example:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/27-remove-element-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/26-remove-duplicates-from-sorted-array-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/">26. Remove Duplicates From Sorted Array 有序数组中去除重复项</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>06 Feb 2018, 10:18</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/array">Array</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/two-pointers">Two Pointers</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example:
Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/26-remove-duplicates-from-sorted-array-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/25-reverse-nodes-in-k-group-%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/">25 Reverse Nodes in K Group 每k个一组翻转链表</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>05 Feb 2018, 11:36</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/linked-list">Linked List</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/25-reverse-nodes-in-k-group-%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/24-swap-nodes-in-pairs-%E6%88%90%E5%AF%B9%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9/">24. Swap Nodes in Pairs 成对交换节点</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>04 Feb 2018, 13:56</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/linked-list">Linked List</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Given a linked list, swap every two adjacent nodes and return its head.
For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.
Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
Difficulty: Medium
解法1 迭代.建立dummy结点(注意之后释放该结点),拿1,2,3,4举例,第一次循环pre=dummy,将1指向3,将2指向1,再将pre设为1
class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode *dummy = new ListNode(-1),*pre = dummy; dummy-&gt;next = head; while (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next) { // t=2 ListNode* t = pre-&gt;next-&gt;next; // 1 -&gt;(指向next) 3 pre-&gt;next-&gt;next = t-&gt;next; // 2 -&gt; 1 t-&gt;next = pre-&gt;next; // pre(dummy) -&gt; t pre-&gt;next = t; // pre = 1 pre = t-&gt;next; //所以第一次while循环后的结果为 //dummy-&gt; t(2) -&gt; 1 -&gt; 3 //pre = 1 然后到下一次循环 } ListNode* res = dummy-&gt;next; delete dummy; dummy = NULL; return res; } };  解法2 递归,先递归到最后两个进行交换,再依次向前迭代.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/24-swap-nodes-in-pairs-%E6%88%90%E5%AF%B9%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/23-merge-k-sorted-lists-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">23. Merge K Sorted Lists 合并k个有序链表</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>31 Jan 2018, 10:59</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/linked-list">Linked List</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/divide-and-conquer">Divide and Conquer</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/heap">Heap</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
Difficulty: Hard
合并k个排序列表.是前面21. Merge Two Sorted Lists 混合插入有序链表的升级版.
解法1 最先想到的就是利用21. Merge Two Sorted Lists 混合插入有序链表拿第一个链表与第二个合并,合并结果在于第三个比较.这样需要合并k-1次才能完成.
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { int n = lists.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/23-merge-k-sorted-lists-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/22-generate-parentheses-%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/">22. Generate Parentheses 生成括号</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>30 Jan 2018, 14:36</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/string">String</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/backtracking">Backtracking</a>&nbsp;&#47;
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/dfs">DFS</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ]  Difficulty: Medium
这道题让我们列举出所有的括号字符串,前面还有一题20. Valid Parentheses 验证括号也是关于括号的.这里让列举出所有可能,可以优先考虑递归和DFS.定义left,right分别表示剩余左括号的数量和剩余的右括号的数量.如果在某次的递归中,left&gt;right说明在已经生成的字符串中右括号的数量大于左括号的数量,是不合理的.当left,right都为0的时候,说明已经生成一个可用的括号串.其实这里有DFS的思想.为什么呢.看看下面是怎样递归的顺序,以题目给的例子n=3.
( (( ((( ((() ((()) ((())) (()()) ~ ()()()  DFS(深度优先),这里可以想象成左括号优先
解法1 就是上面分析的解法
class Solution { public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; res; generateParenthesisDFS(n,n,&quot;&quot;,res); return res; } void generateParenthesisDFS(int left,int right,string out,vector&lt;string&gt;&amp; res) { if (left&gt;right) return; if (left==0 &amp;&amp; right==0) res.
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/22-generate-parentheses-%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blog.longpengfei.com/post/21-merge-two-sorted-lists-%E6%B7%B7%E5%90%88%E6%8F%92%E5%85%A5%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">21. Merge Two Sorted Lists 混合插入有序链表</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>30 Jan 2018, 11:42</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blog.longpengfei.com/tags/leetcode">leetcode</a>
    
  </div>

  
  

  
  
  
  <div>
    <i class="fa fa-codiepie fa-fw"></i>
    
      <a class="post-taxonomy-leetcode" href="http://blog.longpengfei.com/leetcode/linked-list">Linked List</a>
    
  </div>

  
  


</div>

  </header>

  <p>
  Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4  Difficulty: Easy
这道题让我们把两个有序的链表合并成一个有序的链表,与剑指offer 16题完全相同.
解法1 按照剑指offer 16题的递归解法
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (l1==NULL) return l2; if (l2==NULL) return l1; ListNode* head = NULL; if (l1-&gt;val&lt;l2-&gt;val) { head = l1; head-&gt;next = mergeTwoLists(l1-&gt;next,l2); } else { head = l2; head-&gt;next = mergeTwoLists(l2-&gt;next,l1); } return head; } };  解法2 采用循环的方式
  </p>

  
  <footer>
    <a href="http://blog.longpengfei.com/post/21-merge-two-sorted-lists-%E6%B7%B7%E5%90%88%E6%8F%92%E5%85%A5%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  

  


<nav class="pagination" role="pagination">
  
  <a href="http://blog.longpengfei.com/"><i class="fa fa-chevron-left"></i></a>
  
  <span>&nbsp;2 / 6&nbsp;</span>
  
  <a href="http://blog.longpengfei.com/page/3/"><i class="fa fa-chevron-right"></i></a>
  
</nav>



</div>

</div>
</div>
<script src="http://blog.longpengfei.com/js/ui.js"></script>





<script type="text/javascript">
  var _paq = _paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="\/\/analytics.example.com\/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId',  2 ]);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//analytics.example.com/piwik.php?idsite=2" style="border:0;" alt="" /></p></noscript>



</body>
</html>

