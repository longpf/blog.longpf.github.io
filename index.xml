<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>long·pf</title>
    <link>http://blog.longpengfei.com/</link>
    <description>Recent content on long·pf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2018. All rights reserved.</copyright>
    <lastBuildDate>Wed, 24 Jan 2018 17:04:38 +0800</lastBuildDate>
    
	<atom:link href="http://blog.longpengfei.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>9. Palindrome Number 验证回文数字</title>
      <link>http://blog.longpengfei.com/post/9-palindrome-number-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 24 Jan 2018 17:04:38 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/9-palindrome-number-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/</guid>
      <description>Determine whether an integer is a palindrome. Do this without extra space.
Some hints: Could negative integers be palindromes? (ie, -1)
If you are thinking of converting the integer to string, note the restriction of using extra space.
You could also try reversing an integer. However, if you have solved the problem &amp;ldquo;Reverse Integer&amp;rdquo;, you know that the reversed integer might overflow. How would you handle such case?
There is a more generic way of solving this problem.</description>
    </item>
    
    <item>
      <title>8 String to Integer Atoi 把字符串转换成整数</title>
      <link>http://blog.longpengfei.com/post/8-string-to-integer-atoi-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 24 Jan 2018 12:40:36 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/8-string-to-integer-atoi-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
Difficulty: Medium
把字符串转换成整数,和剑指offer 49题相似,不过这里的要求比较多,实现atoi
 判断开头是否有空格 判断开头是否有 &#39;+&#39;,&#39;-&#39; 如果遇到非法字符返回已有的结果 如果超过边界,返回边界值  class Solution { public: int myAtoi(string str) { int len = str.</description>
    </item>
    
    <item>
      <title>7 Reverse Integer 翻转整数</title>
      <link>http://blog.longpengfei.com/post/7-reverse-integer-%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 24 Jan 2018 10:40:15 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/7-reverse-integer-%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>Given a 32-bit signed integer, reverse digits of an integer.
Example 1:
Input: 123 Output: 321  Example 2:
Input: -123 Output: -321  Example 3:
Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
分析 Difficulty: Easy</description>
    </item>
    
    <item>
      <title>6 ZigZag Conversion 之子形转换字符串</title>
      <link>http://blog.longpengfei.com/post/6-zigzag-conversion-%E4%B9%8B%E5%AD%90%E5%BD%A2%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 23 Jan 2018 17:43:43 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/6-zigzag-conversion-%E4%B9%8B%E5%AD%90%E5%BD%A2%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
P A H N A P L S I I G Y I R  And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot; Write the code that will take a string and make this conversion given a number of rows:</description>
    </item>
    
    <item>
      <title>Manacher 马拉车算法</title>
      <link>http://blog.longpengfei.com/post/manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 18 Jan 2018 12:01:24 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</guid>
      <description>Manacher马拉车算法是解决回文子串长度的算法,可以是时间复杂度为O(n).回文字符串就是正着读,反着读都一样的字符串.aba,abba.
由于回文串的长度可奇可偶, 为避免奇偶判断,Manacher的第一步预处理为在字符串的首尾和每个字符的间隙中都插入#,如#a#b#a#,#a#b#b#a#,这样转换后的字符串t恒为奇数.接下里加入一个辅助数组p,其中p[i]表示以t[i]字符为中心的回文子串的半径,若p[i]=1,那该回文子串就是t[i]本身.
#1#2#2#1#2#2# 1212521612321  由于第一个和最后一个字符都是#号,并且也需要搜索回文,为了防止越界,还需要在首尾加上非#号字符,实际操作时,我们只需要给开头加上非#号字符,结尾不用加的原因是字符串的结尾标识为\0,等于默认加过了.从上面可以看出p[i]-1正好为元字符串在i处的回文子串的长度.下面只要求出p数组中的最大值就行.新增两个辅助变量mx和id,其中id为最大回文子串的中心的位置,mx是回文串能延伸到的最右端的位置,这个算法的最核心的一行:
p[i] = mx&amp;gt;i ? min(p[2*id-1],mx-i) : 1;  如图j是i关于id的对称点.
  当mx&amp;gt;i时候p[i]=min(p[2*id-i],mx-i)=min(p[j],mx-i),为什么呢?
此时还需要分开讨论:
当mx-i&amp;gt;p[j]如上图,红色距离大于黄色距离.以j为中心的回文子串包含在id为中心的回文子串中.i和j对称,所以i为中心的回文子串也在id为中心的回文子串中.所以有p[i]=p[j].
当mx-i&amp;gt;p[j]的时候,j为中心的回文子串不一定全部包含在id为中心的回文子串中,基于对称性可知i为中心的回文子串最右端可能超出mx处,就是p[i]&amp;gt;=mx-i,如下图,绿色的部分是相同的.至于p[i]具体能在mx右边延伸到多远,就只能循环向右边扩展边比较，直至不为子回文串。
  对于mx&amp;lt;=i的情况,i在mx的右边未知区域.无法对p[i]做更多的假设,只能p[i]=1,然后去虚幻向右比较扩展。
参考代码如下:
#include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; string Manacher(string s) { //insert &#39;#&#39; string t = &amp;quot;$#&amp;quot;; for (int i = 0;i&amp;lt;s.size();++i){ t += s[i]; t += &amp;quot;#&amp;quot;; } //process t vector&amp;lt;int&amp;gt; p(t.size(),0); int mx = 0,id = 0,resLen = 0,resCenter = 0; for (int i = 1; i &amp;lt; t.</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring 最长回文子字符串</title>
      <link>http://blog.longpengfei.com/post/longest-palindromic-substring-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 15 Jan 2018 17:03:21 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/longest-palindromic-substring-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
Difficulty:Medium
Example:
Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer.  Example:
Input: &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot;  这道题参考Grandyang,他博客里有全套leetcode讲解.
求最长回文串,回文串就是正着读反着读都一样的字符串.下面的解法是以一个字符为中心向两边扩散并比较 
解法1: O(n^2) class Solution { public: public: string longestPalindrome(string s) { int startIdx = 0, left = 0, right = 0, len = 0; for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays两个数组的中位数</title>
      <link>http://blog.longpengfei.com/post/median-of-two-sorted-arrays%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sat, 13 Jan 2018 15:45:29 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/median-of-two-sorted-arrays%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
Example1:
nums1 = [1, 3] nums2 = [2] The median is 2.0  Example2
nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5  分析 解法一:
思路来自Very concise O(log(min(M,N))) iterative solution with detailed explanation 看到O(log (m+n))一般来说就是分治法或是二分搜索,一个数组(长度为N)在中间切一刀,那它左边的索引L为(N-1)/2,右边的索引R为N/2.</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters 子字符串的最大不重复长度</title>
      <link>http://blog.longpengfei.com/post/longest-substring-without-repeating-characters-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Fri, 12 Jan 2018 11:41:10 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/longest-substring-without-repeating-characters-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%95%BF%E5%BA%A6/</guid>
      <description>Given a string, find the length of the longest substring without repeating characters.
Examples:
Given &amp;quot;abcabcbb&amp;quot;, the answer is &amp;quot;abc&amp;quot;, which the length is 3.
Given &amp;quot;bbbbb&amp;quot;, the answer is &amp;quot;b&amp;quot;, with the length of 1.
Given &amp;quot;pwwkew&amp;quot;, the answer is &amp;quot;wke&amp;quot;, with the length of 3. Note that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.
滑动窗口问题,比如abcabcbb,滑动到abca的时候需要丢弃第一个a变成bca,继续向右滑动,每次滑动都要检查有没有重复.感觉涉及到最大,最多的问题都可以试着网哈希表上靠. 
class Solution { public: int lengthOfLongestSubstring(string s) { int size = s.</description>
    </item>
    
    <item>
      <title>Add TwoNumbers 两个链表相加</title>
      <link>http://blog.longpengfei.com/post/add-twonumbers-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Wed, 10 Jan 2018 21:39:18 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/add-twonumbers-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</guid>
      <description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>Two Sum 两数之和等于一个输入的数</title>
      <link>http://blog.longpengfei.com/post/two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0/</link>
      <pubDate>Wed, 10 Jan 2018 19:21:32 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  要返回数组中两个数的索引,这两个数的和等于输入的数.最简单的两层for循环可定不能满足要求.考虑优化时间复杂度,可尝试牺牲时间复杂度. stack?queue?vector?还是hash_map.stack,queue,vector查找都是O(n),hash_map为O(1).接下来尝试用hash_map解决问题. 
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;res; if(nums.</description>
    </item>
    
    <item>
      <title>刷一哈剑指Offer</title>
      <link>http://blog.longpengfei.com/post/atoffer/</link>
      <pubDate>Mon, 08 Jan 2018 21:18:56 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/atoffer/</guid>
      <description>这是前一阵用c++刷过的剑指offer题,做个记录.我的github上有每个题的Xcode项目,方便调试.
目录  1. 二维数组中的查找 2. 字符串中的空格替换 3. 从尾到头打印链表 4. 重建二叉树 5. 两个栈实现队列 6. 旋转数组的最小数字 7. 斐波那契数列 8. 跳台阶 9. 变态跳台阶 10. 矩形覆盖 位运算tip 11. 二进制中1的个数 12. 数值的整数次方 13. 调整数组顺序使奇数位于偶数前面 14. 链表中倒数第k个结点 15. 反转链表 16. 合并两个排序的列表 17. 树的子结构 18. 二叉树的镜像 19. 顺时针打印矩阵 20. 包含min函数的栈 21. 栈的压入、弹出序列 22. 从上到下打印二叉树 23. 二叉搜索树的后序遍历序列 24. 二叉树中和为某一值的路径 25. 复杂链表的复制 二叉树的前中后序遍历 26. 二叉搜索树与双向链表 27. 字符串的排列 28. 数组中出现次数超过一半的数字 红黑树,快排,堆排 29. 最小的K个数 30. 连续子数组的最大和 31. 整数中1出现的次数(从1到n整数中1出现的次数) 32. 把数组排成最小的数 33.</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>http://blog.longpengfei.com/contact/</link>
      <pubDate>Sun, 07 Jan 2018 16:47:06 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/contact/</guid>
      <description>联系方式 :
 QQ : 466142249 Mail : long.pf@outlook.com Mail : long.pf@hotmail.com</description>
    </item>
    
    <item>
      <title>Python笔记</title>
      <link>http://blog.longpengfei.com/post/python-note/</link>
      <pubDate>Sat, 08 Jul 2017 20:03:17 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/python-note/</guid>
      <description>Python学习笔记 这里是我学习廖雪峰python做的笔记.比较长,主要方便回看
关键目录  安装 sublime开发python py基础 list和tuple dict和set 函数 函数的参数 递归函数 高级特性 切片,迭代,列表生成,生成器 函数式编程 map/reduce filter,sort 返回函数,闭包,装饰器,匿名函数 偏函数 模块 面向对象编程 获取对象信息 实例属性和类属性 面向对象高级编程 slots限制class绑定的属性 @property 多重继承 定制类 使用元类 错误,调试和测试 IO编程 进程和线程 正则表达式 常用内建模块 常用第三方模块 virtualenv 图形界面 网络编程 电子邮件  正文 第一个py程序 安装 安装

sublime开发python python3 build  1 type -a python3查看pythons路径 2 Sublime-&amp;gt;Tools-&amp;gt;build system-&amp;gt;new build system 3 修改为
{ &amp;quot;cmd&amp;quot;: [&amp;quot;python3路径&amp;quot;,&amp;quot;-u&amp;quot;,&amp;quot;$file&amp;quot;], }  4 保存为Python3.sublime-build
  macOS用Terminal打开sublime ln -s &amp;quot;/Applications/Sublime Text.</description>
    </item>
    
    <item>
      <title>Swift实现可选协议</title>
      <link>http://blog.longpengfei.com/post/swift-optional-protocol/</link>
      <pubDate>Sun, 12 Mar 2017 20:40:50 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/swift-optional-protocol/</guid>
      <description> Swift实现可选协议 定义
@objc protocol FTMagicMoveTransionFromProtocol { @objc optional func captureView() -&amp;gt; UIView? }  实现
//parent class FTViewController: UIViewController, FTMagicMoveTransionFromProtocol{ func captureView() -&amp;gt; UIView? { return nil } }  //child class FTHomeViewController: FTViewController{ override func captureView() -&amp;gt; UIView { return (selectedCell?.thumbImageView)! } }  </description>
    </item>
    
    <item>
      <title>Swift调用objective-c的framework(非pod)需要注意的</title>
      <link>http://blog.longpengfei.com/post/oc-framework-4-swift/</link>
      <pubDate>Wed, 08 Mar 2017 20:40:50 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/oc-framework-4-swift/</guid>
      <description>swift调用objective-c的framework(非pod)需要注意的  1. 创建AppName-Bridging-Header,并#import&amp;lt;&amp;gt;相关文件 2. General -&amp;gt; Embedded Binaried添加 3. Build Setting -&amp;gt; Swift Compiler-General -&amp;gt; Objective-C Briding Header 添加header的path,如:FaceTube/FaceTube-Bridging-Header.h 4. Link Binary With Libraries 添加相关framework  再就是可以试试把生成framework的项目拖到自己项目中运行生成framework例如这样
这样之后如果还报错 在link Binary With Libraries中添加libc++.tbd应该可以搞定</description>
    </item>
    
    <item>
      <title>UIKit性能优化</title>
      <link>http://blog.longpengfei.com/post/uikit-performance-optimization/</link>
      <pubDate>Thu, 12 Jan 2017 05:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/uikit-performance-optimization/</guid>
      <description>Instrument (command+I) 原文地址
Core Animation : Color Blended Layers :
检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。 对于UIImageView来说，不仅它自身需要是不透明的，它的图片也不能含有alpha通道. PS：如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个sublayer，如果有好的解决办法欢迎告诉我。
Color Hits Green and Misses Red :
表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好. 光栅化的核心在于缓存的思想。
layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去
光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化
// label.layer.shouldRasterize = true
Color Copied Images :
像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。 “Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。 当我们打开JPEG格式的图片时，CPU会进行一系列运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。 CPU主要处理两件事：
把图片从PNG或JPEG等格式中解压出来，得到像素数据 如果GPU不支持这种颜色各式，CPU需要进行格式转换
Color Misaligned Images :
表示如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色 图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。
Color Offscreen-Rendered Yellow :
离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。 会把需要离屏渲染的地方标记为黄色，大部分情况下我们需要尽可能避免黄色的出现。离屏渲染可能会自动触发，也可以手动触发。以下情况可能会导致触发离屏渲染： 重写drawRect方法 有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask layer.shouldRasterize = true
前两者会自动触发离屏渲染，第三种方法是手动开启离屏渲染
设置阴影的时候要指定path 要不会离屏渲染
设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：
Color Compositing Fast-Path Blue:</description>
    </item>
    
    <item>
      <title>哈希表简记</title>
      <link>http://blog.longpengfei.com/post/understanding-hashtable/</link>
      <pubDate>Wed, 11 Jan 2017 05:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/understanding-hashtable/</guid>
      <description>哈希表 散列表(哈希表),是根据键而直接访问在内存存储位置的数据结构.也就是说,他通过计算一个关于键值的函数,将所需查询的数据映射到表中一个位置来访问记录,这加快了查找速度,这个映射函数称作散列函数,存放的数组称作散列表.
一个通俗的例子是,通讯录,通过字母w来查找&amp;rsquo;王&amp;rsquo;,这里用人名作关键字.
基本概念  若关键字为k,则其值存放在f(k)的存储位置上.由此,不需要比较便可直接取得所查记录.f为散列函数,按这个思想简历的表为散列表.
 对不同搞得关键字可能得到同一散列地址,即k1!=k2,f(k1)=f(k2),这种现象叫冲突,k1,k2称为同义词.综上所述根据散列函数f和处理冲突的方法将一组关键字映射到一个有限的连续的地址集(区间)上,并以关键字在地址集中的&amp;rsquo;像&amp;rsquo;作为记录在表中的存储位置,这种表便称为散列表,这一映射过程称为散列造表或散列,所得的存储位置称散列地址.
 若对于关键字集合中的任一个关键字,经散列函数映像到地址结合中任何一个地址的概率是相等的,则称此类散列函数为均匀散列函数,这就是使关键字经过散列函数得到一个&amp;rsquo;随机的地址&amp;rsquo;,从而减少冲突.
  构造散列函数 散列函数能使一个数据序列的访问过程更加迅速有效,通过散列函数,数据元素将被更快定位.
 1. 直接定址法 : 取关键字或关键字的某个线性函数值为散列地址.即hash(k)=a*k+b,其中ab为常数.这种散列函数叫做自身函数. 2. 数字分析法 : 假设关键字是以r为基的数,并且哈希表中可能出现的关键字都是事先知道的,则可取关键字的若干数位组成哈希地址. 3. 平方取中法 : 取关键字平方后的中间几位为哈希地址.一个数平方后的中间几位数和数的每一位都相关,由此使随机分布的关键字得到的哈希地址也是随机的.取得位数由表长决定 4. 折叠法 : 将关键字分割成位数相同的几部分(最后一部分的位数可以不同),然后取这几部分的叠加和(舍去进位)最为哈希地址 5. 随机数法 6. 除留余数法 :取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即hash(k)=k mod p, p&amp;lt;=m.不仅可以对关键字直接取模,也可以在折叠法,平方取中法等运算之后取模.对p的选择很重要,一般取素数或m,若p选择不好,容易产生冲突  处理冲突 为了知道冲突产生的相同散列函数地址所对应的关键字,必须选用另外的散列函数,或者对冲突结果进行处理.而不发生冲突的可能性是非常之小的,所以通常对冲突进行处理.
 开放定址法(open addressing) : hashi = (hash(key) + di) mod m ,其中hash(key)为散列函数,m为散列表长,di为增量序列,i为已发生冲突次数.增量序列可有下列取法:  di = 1,2,3&amp;hellip;(m-1)称为线性探测;即 di = i,或者为其他线性函数.相当于诸葛探测粗放地址的表,知道查到一个空单元,把散列地址存放在该空单元.
di = &amp;plusmn;1&amp;sup2;,&amp;plusmn;2&amp;sup2;,&amp;plusmn;3&amp;sup2;&amp;hellip;&amp;plusmn;k&amp;sup2;,(k&amp;le;m/2),称为平方探测,相对线性探测,相对于发生冲突时探测间隔di = i&amp;sup2;个单元的位置是否为空,如果为空,降低至存放进去
di = 伪随机数,称为 伪随机探测</description>
    </item>
    
    <item>
      <title>AspectsCocoa</title>
      <link>http://blog.longpengfei.com/post/aspectscocoa/</link>
      <pubDate>Tue, 10 Jan 2017 01:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/aspectscocoa/</guid>
      <description>前言 : 本来是想写一个简易高效的rac, 不过在写信号传递的时候没找到好的解决方法,又不想像rac那样在传递的时候不断创建信号,因为要高效嘛.如果大家有啥好的方法麻烦告诉我下QQ466142249,如果发现什么错误,或者某个部分可以有更好的实现也麻烦告诉我下,哈哈哈哈.这里的全部代码在github的这里.
如何使用AspectsCocoa? 添加 :
 [self.label addObserver:self forSelector:@selector(setText:) withBlock:^(AOPObserverInfo *info,NSString *text){ NSLog(@&amp;quot;text = %@&amp;quot;,text); }]; [self.label addObserver:self forSelector:@selector(drawTextInRect:) withBlock:^(AOPObserverInfo *info,NSValue *rectValue){ NSLog(@&amp;quot;rectValue = %@&amp;quot;,rectValue); }];  移除 :
[self.label removeObserver:self forSelector:@selector(setText:)];
or
[self.label removeObserver:self];
详细可以参看demo 
大概思路 其实和KVO的原理有点相似,衍生出来一个中间类,重写setter方法做到键值监听.不过这里不是只有setter方法还有其他普通的方法.再就是普通方法的变化参数需要好好处理下.
 1 . 判断该类是否有这个监听方法 (这里我就直接取这个方法的类方法和实例方法,如果都不存在,则抛出异常) 2 . 判断是否生成过中间类,没生成则生成一个 3 . 查看中间类是否有要监听的方法,没有添加方法 (有关于普通方法的变参问题,我这里是用va_list来处理的) 4 . 储存监听信息和回调  具体实现  1 . 判断该类是否有这个监听方法   Method method = class_getInstanceMethod([self class], selector); if (!</description>
    </item>
    
    <item>
      <title>整理一些ios面试题(偏简单的)</title>
      <link>http://blog.longpengfei.com/post/ios-interview-question-new/</link>
      <pubDate>Tue, 10 Jan 2017 01:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/ios-interview-question-new/</guid>
      <description>这里是一位别的同学整理的
1.MVC 具有什么样的优势，各个模块之间怎么通信，比如点击 Button 后 怎么通知 Model？ 
MVC 模式的优点。
1.低耦合性
2.有利于开发分工
3.有利于组件重用
4.可维护性
button可以通过target-action高速controller,controller通过kvo告诉model
2.两个无限长度链表（也就是可能有环） 判断有没有交点 看这里
3.UITableView 的相关优化
看UIKit性能优化,印象笔记 和 这个
4. KVO、Notification、delegate 各自的优缺点，效率还有使用场景 看这里
5.如何手动通知 KVO 看这里;
6.Objective-C 中的 copy 方法
Objective-c中对象的Copy、MutableCopy、浅拷贝、深拷贝
浅析Objective-C的copy
7. runtime 中，SEL 和 IMP 的区别
SEL : 类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。
IMP:一个函数指针,保存了方法的地址
8 . autoreleasepool 的使用场景和原理
如果你编写的程序不是基于 UI 框架的，比如说命令行工具； 如果你编写的循环中创建了大量的临时对象； 如果你创建了一个辅助线程。
原理解析1
解析2
9 . RunLoop 的实现原理和数据结构，什么时候会用到
深入理解runloop
runloop小结
10 . block 为什么会有循环引用 
认识block
这里有一点没有说明 : arc和mrc中block的区别,就是block内访问或者修改外部变量的时候,arc自动将block处于堆中,mrc栈中</description>
    </item>
    
    <item>
      <title>Git Flow 常用命令</title>
      <link>http://blog.longpengfei.com/post/git-flow-command/</link>
      <pubDate>Fri, 30 Dec 2016 14:52:55 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/git-flow-command/</guid>
      <description>git flow feature start branchname
 开始一个featuer分支,feature分支的名字一般为功能+人名,如capture.xiaoming  git flow feature publish branchname
 将一个featuer分支推到远程,多人开发  git checkout -b feature/branchname origin/feature/branchname * 将远程的featuer分支下到本地开发
git flow feature finish branchname * 合并至本地develop * 删除任务分支
git pull --rebase
git flow release start v6.6.3 * 开始release分支
git flow release publish v6.6.3
git flow release finish v6.6.3 * 合并release分支到master * 在master上打上tag * 合并release到develop * 删除release
git flow hotfix start v6.6.4 * 开始修复分支
git flow hotfix finish v6.</description>
    </item>
    
    <item>
      <title>Git 常用命令简记</title>
      <link>http://blog.longpengfei.com/post/git-command/</link>
      <pubDate>Fri, 30 Dec 2016 14:51:55 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/git-command/</guid>
      <description>前:HEAD关键字是指当前分支的最新一次提交,就是版本库中该分支上的最新版本
git init git init 初始化一个repo,创建一个.git文件夹
git clone git clone url newname nenamew 可以不要
git log git log --oneline 每条log显示一行
git log --oneline --graph 图形化
git log branchname 指定分支log
git log --oneline branch1 ^branch2 在分支1,不在分支2,^为排除
git log --author=[author name]指定作者
git log --grep=keywords筛选commit信息
git log --grep=keywords --author=authorname 是OR的关系,如果想为AND则添加&amp;ndash;all-match
git reflog 对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化 当git reflog 不指定引用的时候,默认列出HEAD的reflog git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD,分支的reflog文件都放在.git/logs/refs目录下的子目录中.
git reflog 可以看到reset的commit
git add git add file
git add . 递归添加工作区的修改到暂缓区
git commit git commit -m &amp;quot;message&amp;quot;</description>
    </item>
    
    <item>
      <title>Swift基础简单笔记</title>
      <link>http://blog.longpengfei.com/post/swift-simple-notes/</link>
      <pubDate>Wed, 30 Nov 2016 14:51:55 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/swift-simple-notes/</guid>
      <description>Swift基础简单笔记 菜鸟Swift
目录  1. 渣渣 2. 函数 3. 闭包 4. 枚举 5. 结构体 6. 类 7. 属性 8. 方法 9. 下标脚本 10. 继承 11. 构造,析构,可选链 12. 自动引用计数 13. 类型转换 14. 扩展 15. 协议 16. 泛型 17. 访问控制  
var aa:Float aa = 3.14 print(aa)  输出 var name = &amp;quot;666&amp;quot; var site = &amp;quot;777&amp;quot; print(&amp;quot;\(name)dddd\(site)&amp;quot;)  16进制小数 : 0xFp2 表示 15 ⨉ 2^2，也就是 60；同样，0xFp-2 表示 15 ⨉ 2^-2，也就是 3.</description>
    </item>
    
  </channel>
</rss>