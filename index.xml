<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>long·pf</title>
    <link>http://blog.longpengfei.com/</link>
    <description>Recent content on long·pf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2018. All rights reserved.</copyright>
    <lastBuildDate>Thu, 25 Jul 2019 17:22:19 +0800</lastBuildDate>
    
	<atom:link href="http://blog.longpengfei.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>52. N Queens II N皇后问题之二</title>
      <link>http://blog.longpengfei.com/post/52-n-queens-ii-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%B9%8B%E4%BA%8C/</link>
      <pubDate>Thu, 25 Jul 2019 17:22:19 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/52-n-queens-ii-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%B9%8B%E4%BA%8C/</guid>
      <description>The n-queens puzzle(难题) is the problem of placing n queens on an n×n chessboard(棋盘) such that no two queens attack each other.
Given an integer n, return all distinct(不同的) solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space respectively(分别地).
Example: Input: 4 Output: [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;..Q.&amp;quot;], [&amp;quot;.</description>
    </item>
    
    <item>
      <title>51. N Queens N皇后问题</title>
      <link>http://blog.longpengfei.com/post/51-n-queens-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 25 Jul 2019 16:54:49 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/51-n-queens-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</guid>
      <description>The n-queens puzzle(难题) is the problem of placing n queens on an n×n chessboard(棋盘) such that no two queens attack each other.
Given an integer n, return all distinct(不同的) solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space respectively(分别地).
 Example: Input: 4 Output: [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;.</description>
    </item>
    
    <item>
      <title>50. Pow(x, n) 求x的n次方</title>
      <link>http://blog.longpengfei.com/post/50-pow/</link>
      <pubDate>Thu, 04 Jul 2019 16:51:09 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/50-pow/</guid>
      <description>Implement pow(x, n), which calculates x raised to the power n (xn).
 Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &amp;lt; x &amp;lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1]  求x的n次方,利用递归这班计算
double myPow3(double x,int n){ if (n==0) return 1; double half = myPow3(x, n/2); if (n%2==0) return half*half; if (n&amp;gt;0) return half*half*x; return half*half/x; }  </description>
    </item>
    
    <item>
      <title>49. Group Anagrams 群组错位词</title>
      <link>http://blog.longpengfei.com/post/49-group-anagrams-%E7%BE%A4%E7%BB%84%E9%94%99%E4%BD%8D%E8%AF%8D/</link>
      <pubDate>Wed, 12 Jun 2019 15:49:38 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/49-group-anagrams-%E7%BE%A4%E7%BB%84%E9%94%99%E4%BD%8D%E8%AF%8D/</guid>
      <description>Given an array of strings, group anagrams together.
Example: Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ]  Note:
All inputs will be in lowercase. The order of your output does not matter.
解法1
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; res; unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; m; for (string str : strs) { string t = str; sort(t.begin(), t.end()); // 这里可以不用判断m[t]存不存在 m[t].push_back(str); } for (auto a : m) { res.</description>
    </item>
    
    <item>
      <title>48. Rotate Image 旋转图像</title>
      <link>http://blog.longpengfei.com/post/48-rotate-image-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Wed, 12 Jun 2019 14:44:16 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/48-rotate-image-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</guid>
      <description>Medium
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
 Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], i=0,j=1,n=4 [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ]  这道题让我们将一个n*n的二维矩阵顺时针旋转90度.</description>
    </item>
    
    <item>
      <title>47. PermutationsII 全排列2</title>
      <link>http://blog.longpengfei.com/post/47-permutationsii-%E5%85%A8%E6%8E%92%E5%88%972/</link>
      <pubDate>Thu, 06 Jun 2019 17:19:32 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/47-permutationsii-%E5%85%A8%E6%8E%92%E5%88%972/</guid>
      <description>Given a collection of numbers that might contain duplicates, return all possible unique permutations.
Example:
 Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ]  跟上道题不一样的地方就是会有重复的数字
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // 这里用set来去重,因为递归回退的时候可能会有重复的元素 set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res{}; if (nums.size()==0) return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(); sort(nums.begin(), nums.end()); permuteUniqueCore(res, nums, 0, nums.size()); return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; (res.begin(),res.end()); } void permuteUniqueCore(set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;res,vector&amp;lt;int&amp;gt; &amp;amp;nums,int k,int n){ if (k == n) { printArr(nums); res.insert(nums); return; } for (int i = k; i&amp;lt;n; i++) { if (nums[k]==nums[i] &amp;amp;&amp;amp; i!</description>
    </item>
    
    <item>
      <title>46 Permutations 全排列</title>
      <link>http://blog.longpengfei.com/post/46-permutations-%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 06 Jun 2019 15:56:27 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/46-permutations-%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>Given a collection of distinct(不同) integers, return all possible permutations(全排列).
Example:
 Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  这道题跟这道题https://github.com/longpf/AtOffer#27-字符串的排列简直一模一样
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res{}; if (nums.size() == 0) return res; permuteCore(res, nums, 0, nums.size()); return res; } void permuteCore(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;res,vector&amp;lt;int&amp;gt; &amp;amp;num,int k,int n){ if (k == n) { res.push_back(num); return; } for (int i = k; i&amp;lt;n; i++) { swap(num[i], num[k]); permuteCore(res, num, k+1, n); swap(num[i], num[k]); } }  </description>
    </item>
    
    <item>
      <title>45. Jump Game 2 跳跃游戏2</title>
      <link>http://blog.longpengfei.com/post/45-jump-game2/</link>
      <pubDate>Wed, 05 Jun 2019 16:55:50 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/45-jump-game2/</guid>
      <description>Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Your goal is to reach the last index in the minimum number of jumps.
Example:
Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title>Ffmpeg Build 相关</title>
      <link>http://blog.longpengfei.com/post/ffmpeg-build-%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Fri, 09 Nov 2018 16:44:31 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/ffmpeg-build-%E7%9B%B8%E5%85%B3/</guid>
      <description>ffmpeg在iOS下的编译(不包括x264,aac的库) 1. 下载gas-preprocessor.pl  下载地址https://github.com/libav/gas-preprocessor 将gas-preprocessor.pl文件拷贝到/usr/local/bin/目录下 chmod 777 /usr/local/bin/gas-preprocessor.pl开启执行权限  2. 安装yasm  brew install yasm  3. 下载编译脚本  下载地址https://github.com/applexiaohao/FFmpeg-iOS-build-script,脚本中有下载ffmpeg的操作. 这步也可用x264,fdk-aac编译到ffmpeg中提到的脚本 脚本中要改下SOURCE=&amp;quot;ffmpeg-4.0.2&amp;quot;为ffmpeg的版本号我当前为4.0.2. 还需要改下DEPLOYMENT_TARGET=&amp;quot;8.0&amp;quot;iOS支持版本. 执行./build-ffmpeg.sh得到FFmpeg-iOS这个文件夹就是我们需要导入的  4. 导入及头文件  导入FFmpeg-iOS文件夹 Header Search Paths中添加$(PROJECT_DIR)/项目名字/FFmpeg-iOS/include 需要的依赖的库如下:
VideoToolbox.framework //硬解 AudioToolbox.framework libiconv.tbd libbz2.tbd libz.tbd   编译x264 视频编码用的库
 下在x264源码,下载地址http://www.videolan.org/developers/x264.html. 或直接git clone http://git.videolan.org/git/x264.git下载 下载编译脚本https://github.com/kewlbear/x264-ios. 执行脚本./build-x264.sh 如果遇到Out of tree builds are impossible with config.h/x264_config.h in source dir.,需要删除x264中的config.h和x264_config.h 如果编译后只有arm64架构的,则需./build-x264.sh armv7这样编译出其他需要的架构库,之后再./build-x264.sh lipo合成 编译x86_64架构的时候需要先brew install nasm 这样i386架构还是编译出来,因为这个架构已经用到,暂时不纠结  编译faac 音频编码用的库</description>
    </item>
    
    <item>
      <title>44. Wildcard Matching 通配符匹配</title>
      <link>http://blog.longpengfei.com/post/44-wildcard-matching-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Tue, 18 Sep 2018 18:12:18 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/44-wildcard-matching-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</guid>
      <description>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &#39;?&#39; and &#39;*&#39;. &#39;?&#39; Matches any single character. &#39;*&#39; Matches any sequence of characters (including the empty sequence).  The matching should cover the entire input string (not partial).
Note:
 s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ?</description>
    </item>
    
    <item>
      <title>Small Algorithm</title>
      <link>http://blog.longpengfei.com/post/small-algorithm/</link>
      <pubDate>Tue, 31 Jul 2018 21:39:35 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/small-algorithm/</guid>
      <description>这里简单记录一些常用而又老忘记小算法
 快排 红黑树 堆排 合并 打印菱形 验证ipv4,ipv6 二维数组中的查找 链表中倒数第k个结点 翻转链表 二叉树镜像 二叉树遍历 最小的k个数  快排 
https://baike.baidu.com/item/快速排序算法/369842?fr=aladdin
#include &amp;lt;iostream&amp;gt; using namespace std; void Qsort(int a[], int low, int high) { if(low &amp;gt;= high) { return; } int first = low; int last = high; int key = a[first];/*用字表的第一个记录作为枢轴*/ while(first &amp;lt; last) { while(first &amp;lt; last &amp;amp;&amp;amp; a[last] &amp;gt;= key) { --last; } a[first] = a[last];/*将比第一个小的移到低端*/ while(first &amp;lt; last &amp;amp;&amp;amp; a[first] &amp;lt;= key) { ++first; } a[last] = a[first]; /*将比第一个大的移到高端*/ } a[first] = key;/*枢轴记录到位*/ Qsort(a, low, first-1); Qsort(a, first+1, high); }  合并</description>
    </item>
    
    <item>
      <title>146. LRU Cache 最近最少使用置换缓存器</title>
      <link>http://blog.longpengfei.com/post/146-lru-cache-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%BC%93%E5%AD%98%E5%99%A8/</link>
      <pubDate>Mon, 30 Jul 2018 10:25:51 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/146-lru-cache-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%BC%93%E5%AD%98%E5%99%A8/</guid>
      <description>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>43. Multiply Strings 字符串相乘</title>
      <link>http://blog.longpengfei.com/post/43-multiply-strings-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Tue, 24 Jul 2018 11:08:41 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/43-multiply-strings-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</guid>
      <description>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Example 1:
Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot; Output: &amp;quot;6&amp;quot;  Example 2:
Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot; Output: &amp;quot;56088&amp;quot;  Note:
 The length of both num1 and num2 is &amp;lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself.</description>
    </item>
    
    <item>
      <title>42. Trapping Rain Water 收集雨水</title>
      <link>http://blog.longpengfei.com/post/42-trapping-rain-water-%E6%94%B6%E9%9B%86%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Thu, 19 Jul 2018 11:28:13 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/42-trapping-rain-water-%E6%94%B6%E9%9B%86%E9%9B%A8%E6%B0%B4/</guid>
      <description>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
Example:
Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6  解法1 这道题给出一个数组,每个元素是一个宽为1的bar,问这些bar组成的图行最多能装多少水,就是图上蓝色的部分.如果当前位置高度大于两边的高度,我们就认为当前位置对结果有贡献.当前位置的贡献值,为左边高度的最大值和右边高度的最大值,取其中最小的和当前的高度相减.
class Solution { public: int trap(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l=0,r=height.size()-1,level=0,water=0; while(l &amp;lt; r){ int lower = height[height[l]&amp;lt;height[r]?</description>
    </item>
    
    <item>
      <title>41. First Missing Positive 首个缺失的正数</title>
      <link>http://blog.longpengfei.com/post/41-first-missing-positive-%E9%A6%96%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/</link>
      <pubDate>Fri, 13 Jul 2018 18:36:37 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/41-first-missing-positive-%E9%A6%96%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/</guid>
      <description>Given an unsorted integer array, find the smallest missing positive integer.
Example 1:
Input: [1,2,0] Output: 3  Example 2:
Input: [3,4,-1,1] Output: 2  Example 3:
Input: [7,8,9,11,12] Output: 1  Note:
Your algorithm should run in O(n) time and uses constant extra space.
Difficulty: Hard
这道题让我们找出数组中首个缺失的整数. 并且限定了时间负责度为O(n),空间复杂度为O(1),就是不让新建新的集合. 那这样只能在原数组上进行操作. 这里只能是把对应的数放到对应的索引上.比如例2中,3需要放到index为2的位置上,1要放到index为0的位置上.4和-1因为没有对应的索引被舍弃,-1本来就是负数,4越界了.这样先通过一次for循环排好数值对应的索引.再通过一次for循环找到第一个位置不对的就ok. 
class Solution { public: int firstMissingPositive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if (n==0) return 1; for (int i=0;i&amp;lt;n;i++){ while (nums[i]&amp;gt;0 &amp;amp;&amp;amp; nums[i]&amp;lt;=n &amp;amp;&amp;amp; nums[i]!</description>
    </item>
    
    <item>
      <title>40. Combination Sum II 组合之和之二</title>
      <link>http://blog.longpengfei.com/post/40-combination-sum-ii-%E7%BB%84%E5%90%88%E4%B9%8B%E5%92%8C%E4%B9%8B%E4%BA%8C/</link>
      <pubDate>Thu, 28 Jun 2018 12:23:10 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/40-combination-sum-ii-%E7%BB%84%E5%90%88%E4%B9%8B%E5%92%8C%E4%B9%8B%E4%BA%8C/</guid>
      <description>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.
Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]  Example 2:</description>
    </item>
    
    <item>
      <title>39. Combination Sum 组合之和</title>
      <link>http://blog.longpengfei.com/post/39-combination-sum-%E7%BB%84%E5%90%88%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 20 Jun 2018 14:32:45 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/39-combination-sum-%E7%BB%84%E5%90%88%E4%B9%8B%E5%92%8C/</guid>
      <description>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.
Example 1:
Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ]  Example 2:</description>
    </item>
    
    <item>
      <title>38. Count and Say 计数和读法</title>
      <link>http://blog.longpengfei.com/post/38-count-and-say-%E8%AE%A1%E6%95%B0%E5%92%8C%E8%AF%BB%E6%B3%95/</link>
      <pubDate>Tue, 19 Jun 2018 18:28:06 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/38-count-and-say-%E8%AE%A1%E6%95%B0%E5%92%8C%E8%AF%BB%E6%B3%95/</guid>
      <description>The count-and-say sequence is the sequence of integers with the first five terms as following:
1. 1 2. 11 3. 21 4. 1211 5. 111221  1 is read off as &amp;quot;one 1&amp;quot; or 11.
11 is read off as &amp;quot;two 1s&amp;quot; or 21.
21 is read off as &amp;quot;one 2, then one 1&amp;quot; or 1211.
Given an integer n, generate the nth term of the count-and-say sequence.
Note: Each term of the sequence of integers will be represented as a string.</description>
    </item>
    
    <item>
      <title>37. Sudoku Solver 求数独的一个解</title>
      <link>http://blog.longpengfei.com/post/37-sudoku-solver-%E6%B1%82%E6%95%B0%E7%8B%AC%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3/</link>
      <pubDate>Tue, 29 May 2018 15:18:20 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/37-sudoku-solver-%E6%B1%82%E6%95%B0%E7%8B%AC%E7%9A%84%E4%B8%80%E4%B8%AA%E8%A7%A3/</guid>
      <description>Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
 Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.  Empty cells are indicated by the character &amp;lsquo;.</description>
    </item>
    
    <item>
      <title>36. Valid Sudoku 验证数独</title>
      <link>http://blog.longpengfei.com/post/36-valid-sudoku-%E9%AA%8C%E8%AF%81%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Mon, 28 May 2018 18:57:04 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/36-valid-sudoku-%E9%AA%8C%E8%AF%81%E6%95%B0%E7%8B%AC/</guid>
      <description>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.
The Sudoku board could be partially filled, where empty cells are filled with the character &amp;lsquo;.</description>
    </item>
    
    <item>
      <title>35. Search Insert Position 搜索插入位置</title>
      <link>http://blog.longpengfei.com/post/35-search-insert-position-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 27 Mar 2018 14:54:16 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/35-search-insert-position-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You may assume no duplicates in the array.
Example 1 :
Input: [1,3,5,6], 5 Output: 2  Example 2 :
Input: [1,3,5,6], 2 Output: 1  Example 3 :
Input: [1,3,5,6], 7 Output: 4  Example 4 :</description>
    </item>
    
    <item>
      <title>34. Search for a Range 搜索一个范围</title>
      <link>http://blog.longpengfei.com/post/34-search-for-a-range-%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Mon, 19 Mar 2018 10:46:27 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/34-search-for-a-range-%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA%E8%8C%83%E5%9B%B4/</guid>
      <description>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
For example, Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].
解法1 这道题让我们在一个有序数组中查找与输入target相同的起始位置和结束位置,限定时间复杂度为O(logn),这个是典型的二分查找时间复杂度.这道题我们先采用二分法找到一个与target相同的index,再想index的左边和右边搜索.
class Solution { public: vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int index = search(nums,0,nums.</description>
    </item>
    
    <item>
      <title>url到内容返回经历了蛇</title>
      <link>http://blog.longpengfei.com/post/url2content/</link>
      <pubDate>Fri, 16 Mar 2018 19:14:31 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/url2content/</guid>
      <description>目录  url到内容返回经历了蛇 dns解析过程 CDN的基本工作过程  
url到内容返回经历了蛇  1 把url分割成几个部分: 协议,网络地址,资源路径.其中网络地址只是该链接网络上哪一台计算机,可以使域名或者ip地址,可以包括端口号;协议是从该计算机获取资源的方式,常见的HTTP,FTP,不同的协议有不同的通讯内容格式;资源路径指示从服务器上获取哪一项资源.
 例如: http://www.guokr.com/question/554991/ 协议部分 http 网络地址 www.guokr.com 资源路径 /question/554991/  2 如果地址不是一个ip地址,通过DNS(域名系统)将该地址解析成ip地址.ip地址对应着网络上一台计算机,DNS服务器本身也有IP,你的网络设置包含DNS服务器的ip.
 例如 www.guokr.com不是一个ip,向DNS询问请求www.guokr.com对应的ip: 111.13.57.142.这个过程里,你的电脑直接询问DNS服务器可能没www.guokr.com对应的ip,就会想他的上级服务器学问,上级服务器同样可能没有,就一次一层层向上找,最高可达根结点,找到或者全部找不到位置  3 如果地址不包括端口号,根据协议的偶人端口号确定一个.端口号之于计算机就想窗口号之于银行.
 例如www.guokr.com不包括端口号,http协议默认端口号是80.如果输入的url是http://www.guokr.com:8080/那表示不适用默认的端口号,  4 向第2和第3步确定的ip和端口号发起网络连接
 列入向111.13.57.142的80端口发起连接  5 根据http协议要求,组织一个请求的数据包,包含大量请求信息.包括请求的资源路径,你的身份.
 例如: 用自然语言来表达这个数据包,大概就是:请求/question/554991/d我的身份是xxxxx   6 服务器响应请求.将数据返回给浏览器.数据可能是页面,页面的布局,文字,图片,脚本等.如果资源路径只是的资源不存在,服务器就会返回注明的404错误.
 7 如果第6步返回的是一个页面,根据页面里的一些外链的URL,例如图片的地址,按照1~6再次获取.
 8 根据资源的类型,将资源组织成屏幕上显示的图像.这个过程叫渲染.
 9 将渲染好的页面图像显示出来,并开始响应用户的操作.
  
dns解析过程  1. 在浏览器中输入www.qq.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用合格ip地址映射,完成域名解析 2. 如果hosts没有,则查找dns解析器缓存,是否有这个网址映射关系,如果有,返回 3. 如果没有,首先会找tcp/ip参数中设置的首选dns服务器,在此我们叫他本地dns服务器,此服务器收到查询时,如果要查询的域名,包含在本地配置区域资源中,则返回解析结果给客户机,此解析具有权威性 如果要查询的域名,不由本地dns服务器区域解析,但改服务器已缓存了此网址映射关系,则返回该ip,此解析不具有权威性. 5.</description>
    </item>
    
    <item>
      <title>33. Search in Rotated Sorted Array 在旋转有序数组中搜索</title>
      <link>http://blog.longpengfei.com/post/33-search-in-rotated-sorted-array-%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Tue, 27 Feb 2018 10:38:10 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/33-search-in-rotated-sorted-array-%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%90%9C%E7%B4%A2/</guid>
      <description>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Difficulty: Medium
这道题让我们求一个旋转有序数组中是否存在一个给定的值,存在返回下标,不存在返回-1.如体重的例子0 1 2 4 5 6 7,我们不知道从哪开始旋转的,他的选择情况有7种</description>
    </item>
    
    <item>
      <title>32. Longest Valid Parentheses 最长有效括号</title>
      <link>http://blog.longpengfei.com/post/32-longest-valid-parentheses-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 26 Feb 2018 13:27:57 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/32-longest-valid-parentheses-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>Given a string containing just the characters &amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo;, find the length of the longest valid (well-formed) parentheses substring.
For &amp;ldquo;(()&amp;rdquo;, the longest valid parentheses substring is &amp;ldquo;()&amp;rdquo;, which has length = 2.
Another example is &amp;ldquo;)()())&amp;rdquo;, where the longest valid parentheses substring is &amp;ldquo;()()&amp;rdquo;, which has length = 4.
Difficulty: Hard
这道题比20. Valid Parentheses 验证括号难一些.
解法1 还是利用栈来求解,并定义start记录合法括号串的起始位置.遍历字符串,如果遇到左括号,则将当前下标压栈,如果遇到右括号,如果当前栈为空,则将下一个位置的下标记为start,如果栈不为空,则将栈顶元素取出.此时如果站为空,则更新结果和i-start+1的最大值,否则更新结果为i-栈顶元素的最大值.
class Solution { public: int longestValidParentheses(string s) { int res = 0,start = 0; stack&amp;lt;int&amp;gt; m; for (int i=0;i&amp;lt;s.</description>
    </item>
    
    <item>
      <title>31. Next Permutation 下一个排列</title>
      <link>http://blog.longpengfei.com/post/31-next-permutation-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 26 Feb 2018 11:02:34 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/31-next-permutation-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
      <description>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
The replacement must be in-place, do not allocate extra memory.
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1  Difficulty: Medium</description>
    </item>
    
    <item>
      <title>30. Substring With Concatenation of All Words 串联所有单词的子串</title>
      <link>http://blog.longpengfei.com/post/30-substring-with-concatenation-of-all-words-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 08 Feb 2018 16:33:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/30-substring-with-concatenation-of-all-words-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</guid>
      <description>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
For example, given:
s: &amp;quot;barfoothefoobarman&amp;quot;
words: [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;]
You should return the indices: [0,9].
(order does not matter).
Difficulty: Hard
这道题让我们求串联所有单词的子串.所有单词来自输入的数组.所有单词的长度一样,串联的顺序不一定.如题中的例子,可以串联成foobar, barfoo. 这里我们用两个哈希表,一个用来存输入单词数组的每个单词和其的出现次数.然后遍历输入的字符串.设单词的个数为n,每个单词长度为m.每次遍历检查母字符串从该位置开始,每m截取一下查看在第一个哈希表是否存在.如果存在,存入第二个哈希表.如果n个次截取都匹配则这次遍历是符合要求的,存一下结果.
解法1 就是上面分析
class Solution { public: vector&amp;lt;int&amp;gt; findSubstring(string s, vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;int&amp;gt;res; if (s.</description>
    </item>
    
    <item>
      <title>29. Divide Two Integers 两数相除</title>
      <link>http://blog.longpengfei.com/post/29-divide-two-integers-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</link>
      <pubDate>Wed, 07 Feb 2018 16:45:36 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/29-divide-two-integers-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</guid>
      <description>Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT.
Difficulty: Medium
这道题让我们求两个数相除A/B,并且不让使用乘法,除法,取余运算.这样我们只能优先想到位运算和加减法了. 假设A&amp;gt;B,最容易想到的是把A-B赋值给A,并且结果+1,然后再把A-B赋值给A,结果+1.这样一直下去.不过如果是2147483647/1这种情况不会不会通过OJ,因为效率太低,会提示Time Limit Exceeded,不可行.回头想想上面的位运算还没用到,如果A&amp;gt;2*B那么结果是不是加2,如果A&amp;gt;2*2*2B结果是不是加2*2.定义t为除数,p为结果的计数m为被除数的绝对值,n为除数的绝对值.例如100/2
   t
(除数) p
(计数) res
(结果) m
(被除数) t
(除数) p
(计数) res
(结果) m
(被除数) t
(除数) p
(计数) res
(结果) m
(被除数)     2 1 32 36 2 1 48 4 2 1 50 0   4 2   4 2   4 2     8 4   8 4         16 8   16 8         32 16   32 16         64 32              解法1 class Solution { public: int divide(int dividend, int divisor) { if (divisor==0||(dividend==INT_MIN&amp;amp;&amp;amp;divisor==-1)) return INT_MAX; int sign = ((dividend&amp;lt;0)^(divisor&amp;lt;0))?</description>
    </item>
    
    <item>
      <title>28. Implement strStr() 实现strStr()函数</title>
      <link>http://blog.longpengfei.com/post/28-implement-strstr-%E5%AE%9E%E7%8E%B0strstr%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 06 Feb 2018 11:37:27 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/28-implement-strstr-%E5%AE%9E%E7%8E%B0strstr%E5%87%BD%E6%95%B0/</guid>
      <description>Implement strStr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2  Example 2:
Input: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; Output: -1  Difficulty: Easy
这道题让我们找出字符串中某个子字符串第一次出现的index.如果子字符串的长度为0,则返回0,如果子字符传的长度大于母字符串,则返回-1.遍历字符串的时候只需要遍历到剩下的长度等于字符串的位置即可.
class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; int m = haystack.size(),n=needle.size(); if (m&amp;lt;n) return -1; for (int i=0;i&amp;lt;=m-n;++i) { int j=0; for (j=0;j&amp;lt;n;j++) if (haystack[i+j]!</description>
    </item>
    
    <item>
      <title>27. Remove Element 移除元素</title>
      <link>http://blog.longpengfei.com/post/27-remove-element-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 06 Feb 2018 10:46:02 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/27-remove-element-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>Given an array and a value, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title>26. Remove Duplicates From Sorted Array 有序数组中去除重复项</title>
      <link>http://blog.longpengfei.com/post/26-remove-duplicates-from-sorted-array-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Tue, 06 Feb 2018 10:18:16 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/26-remove-duplicates-from-sorted-array-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example:
Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#39;t matter what you leave beyond the new length.</description>
    </item>
    
    <item>
      <title>25 Reverse Nodes in K Group 每k个一组翻转链表</title>
      <link>http://blog.longpengfei.com/post/25-reverse-nodes-in-k-group-%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 05 Feb 2018 11:36:38 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/25-reverse-nodes-in-k-group-%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.</description>
    </item>
    
    <item>
      <title>24. Swap Nodes in Pairs 成对交换节点</title>
      <link>http://blog.longpengfei.com/post/24-swap-nodes-in-pairs-%E6%88%90%E5%AF%B9%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 04 Feb 2018 13:56:46 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/24-swap-nodes-in-pairs-%E6%88%90%E5%AF%B9%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head.
For example, Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
Difficulty: Medium
解法1 迭代.建立dummy结点(注意之后释放该结点),拿1,2,3,4举例,第一次循环pre=dummy,将1指向3,将2指向1,再将pre设为1
class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode *dummy = new ListNode(-1),*pre = dummy; dummy-&amp;gt;next = head; while (pre-&amp;gt;next &amp;amp;&amp;amp; pre-&amp;gt;next-&amp;gt;next) { // t=2 ListNode* t = pre-&amp;gt;next-&amp;gt;next; // 1 -&amp;gt;(指向next) 3 pre-&amp;gt;next-&amp;gt;next = t-&amp;gt;next; // 2 -&amp;gt; 1 t-&amp;gt;next = pre-&amp;gt;next; // pre(dummy) -&amp;gt; t pre-&amp;gt;next = t; // pre = 1 pre = t-&amp;gt;next; //所以第一次while循环后的结果为 //dummy-&amp;gt; t(2) -&amp;gt; 1 -&amp;gt; 3 //pre = 1 然后到下一次循环 } ListNode* res = dummy-&amp;gt;next; delete dummy; dummy = NULL; return res; } };  解法2 递归,先递归到最后两个进行交换,再依次向前迭代.</description>
    </item>
    
    <item>
      <title>23. Merge K Sorted Lists 合并k个有序链表</title>
      <link>http://blog.longpengfei.com/post/23-merge-k-sorted-lists-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 31 Jan 2018 10:59:05 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/23-merge-k-sorted-lists-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
Difficulty: Hard
合并k个排序列表.是前面21. Merge Two Sorted Lists 混合插入有序链表的升级版.
解法1 最先想到的就是利用21. Merge Two Sorted Lists 混合插入有序链表拿第一个链表与第二个合并,合并结果在于第三个比较.这样需要合并k-1次才能完成.
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { int n = lists.</description>
    </item>
    
    <item>
      <title>22. Generate Parentheses 生成括号</title>
      <link>http://blog.longpengfei.com/post/22-generate-parentheses-%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Tue, 30 Jan 2018 14:36:53 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/22-generate-parentheses-%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/</guid>
      <description>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[ &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; ]  Difficulty: Medium
这道题让我们列举出所有的括号字符串,前面还有一题20. Valid Parentheses 验证括号也是关于括号的.这里让列举出所有可能,可以优先考虑递归和DFS.定义left,right分别表示剩余左括号的数量和剩余的右括号的数量.如果在某次的递归中,left&amp;gt;right说明在已经生成的字符串中右括号的数量大于左括号的数量,是不合理的.当left,right都为0的时候,说明已经生成一个可用的括号串.其实这里有DFS的思想.为什么呢.看看下面是怎样递归的顺序,以题目给的例子n=3.
( (( ((( ((() ((()) ((())) (()()) ~ ()()()  DFS(深度优先),这里可以想象成左括号优先
解法1 就是上面分析的解法
class Solution { public: vector&amp;lt;string&amp;gt; generateParenthesis(int n) { vector&amp;lt;string&amp;gt; res; generateParenthesisDFS(n,n,&amp;quot;&amp;quot;,res); return res; } void generateParenthesisDFS(int left,int right,string out,vector&amp;lt;string&amp;gt;&amp;amp; res) { if (left&amp;gt;right) return; if (left==0 &amp;amp;&amp;amp; right==0) res.</description>
    </item>
    
    <item>
      <title>21. Merge Two Sorted Lists 混合插入有序链表</title>
      <link>http://blog.longpengfei.com/post/21-merge-two-sorted-lists-%E6%B7%B7%E5%90%88%E6%8F%92%E5%85%A5%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 30 Jan 2018 11:42:00 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/21-merge-two-sorted-lists-%E6%B7%B7%E5%90%88%E6%8F%92%E5%85%A5%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  Difficulty: Easy
这道题让我们把两个有序的链表合并成一个有序的链表,与剑指offer 16题完全相同.
解法1 按照剑指offer 16题的递归解法
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (l1==NULL) return l2; if (l2==NULL) return l1; ListNode* head = NULL; if (l1-&amp;gt;val&amp;lt;l2-&amp;gt;val) { head = l1; head-&amp;gt;next = mergeTwoLists(l1-&amp;gt;next,l2); } else { head = l2; head-&amp;gt;next = mergeTwoLists(l2-&amp;gt;next,l1); } return head; } };  解法2 采用循环的方式</description>
    </item>
    
    <item>
      <title>20. Valid Parentheses 验证括号</title>
      <link>http://blog.longpengfei.com/post/20-valid-parentheses-%E9%AA%8C%E8%AF%81%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 29 Jan 2018 18:57:44 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/20-valid-parentheses-%E9%AA%8C%E8%AF%81%E6%8B%AC%E5%8F%B7/</guid>
      <description>Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
The brackets must close in the correct order, &amp;quot;()&amp;quot; and &amp;quot;()[]{}&amp;quot; are all valid but &amp;quot;(]&amp;quot; and &amp;quot;([)]&amp;quot; are not.
Difficulty: Easy
这道题让我们验证字符串是否是可用的括号,这个字符串只有括号.需要用到栈,当遇到左括号的时候压入到栈里,遇到右括号的时候需要检查栈顶元素是否为对应的左括号,如果不是对应的就返回false.
class Solution { public: bool isValid(string s) { stack&amp;lt;char&amp;gt; parentheses; for (int i = 0; i&amp;lt;s.size();i++){ if (s[i]==&#39;(&#39;||s[i]==&#39;[&#39;||s[i]==&#39;{&#39;) parentheses.push(s[i]); else { if (parentheses.empty()) return false; if (s[i]==&#39;)&#39; &amp;amp;&amp;amp; parentheses.</description>
    </item>
    
    <item>
      <title>19. Remove Nth Node From End of List 移除链表倒数第N个节点</title>
      <link>http://blog.longpengfei.com/post/19-remove-nth-node-from-end-of-list-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 29 Jan 2018 18:08:29 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/19-remove-nth-node-from-end-of-list-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>Given a linked list, remove the nth node from the end of list and return its head.
For example,
 Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.  Note:
Given n will always be valid. Try to do this in one pass.
Difficulty: Medium
这道题让我们溢出链表中第N个节点,并制定n为有效的,就是n不会大于链表元素的总个数.看网上说这道题在问的时候可能会加上限制在一次循环的条件完成.如果用一次循环完成的话,就不能单独用一次循环来求链表元素的个数,要在循环到要删除的元素的位置时就该删除该元素.所以需要一点技巧. 我们可以定义两个指针pre,cur.先让cur前进N步,如果此时cur指向的为NULL,说明该链表的长度为N,所以移除首个元素就可以.如果cur指向的不为NULL,那么此时同时让pre,cur同时前进,直到cur指向最后一个元素,此时pre指向的就是倒数第N个元素,删除即可.
剑指offer 56题与这道题稍微有点像,可以一起看下
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { if (!</description>
    </item>
    
    <item>
      <title>18. 4Sum 四数之和</title>
      <link>http://blog.longpengfei.com/post/18-4sum-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 29 Jan 2018 17:08:47 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/18-4sum-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]  Difficulty: Medium</description>
    </item>
    
    <item>
      <title>17. Letter Combinations of a Phone Number 电话号码的字母组合</title>
      <link>http://blog.longpengfei.com/post/17-letter-combinations-of-a-phone-number-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Mon, 29 Jan 2018 14:33:03 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/17-letter-combinations-of-a-phone-number-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>Given a digit string, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below.
Input: Digit string &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].  Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.
这道题让我们求电话号码的字母组合, 既2~9中,每个数字都代表2到3个字母,然后给出一个数字的字符串,求出这串数字可能代表的所有字母串.这道题可以用DFS的思想解决,关于DFS可以看二叉树 深度优先搜索（DFS）、广度优先搜索（BFS）,可以简单的了解一下.那为什么说是DFS思想呢,比如给出&amp;rdquo;2345&amp;rdquo;,那个对应的结果为adgj,adgk,adgl,adhj,adhk,adhl...cfil这个顺序可以看做DFS的思想.大概这个意思.
解法1 解法1就是上面的分析的解法.
class Solution { public: vector&amp;lt;string&amp;gt; letterCombinations(string digits) { vector&amp;lt;string&amp;gt; res; if (digits.</description>
    </item>
    
    <item>
      <title>16. 3Sum Closest 最近三数之和</title>
      <link>http://blog.longpengfei.com/post/16-3sum-closest-%E6%9C%80%E8%BF%91%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 29 Jan 2018 10:09:16 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/16-3sum-closest-%E6%9C%80%E8%BF%91%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
 For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</description>
    </item>
    
    <item>
      <title>15. 3Sum 三数之和</title>
      <link>http://blog.longpengfei.com/post/15-3sum-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 27 Jan 2018 17:52:39 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/15-3sum-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note: The solution set must not contain duplicate triplets.
For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  这道题比Two Sum 两数之和等于一个输入的数复杂一些.</description>
    </item>
    
    <item>
      <title>14. Longest Common Prefix 最长共同前缀</title>
      <link>http://blog.longpengfei.com/post/14-longest-common-prefix-%E6%9C%80%E9%95%BF%E5%85%B1%E5%90%8C%E5%89%8D%E7%BC%80/</link>
      <pubDate>Sat, 27 Jan 2018 16:43:30 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/14-longest-common-prefix-%E6%9C%80%E9%95%BF%E5%85%B1%E5%90%8C%E5%89%8D%E7%BC%80/</guid>
      <description>Write a function to find the longest common prefix string amongst an array of strings.
Difficulty: Easy
可以把输入的字符串数组,看成一个char的二维数组,定义指针i,j分别代表行数和列数,逐列查找,如果char[i][j]不等于char[0][j]或者第i个字符串的长度小于j就可以返回之前的结果了.
class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if (strs.empty()) return &amp;quot;&amp;quot;; string res = &amp;quot;&amp;quot;; for (int j=0;j&amp;lt;strs[0].size();j++) { char c = strs[0][j]; for (int i=1;i&amp;lt;strs.size();i++) { if (j&amp;gt;=strs[i].size() || strs[i][j]!=c) return res; } res += c; } return res; } };  </description>
    </item>
    
    <item>
      <title>13. Roman to Integer 罗马数字转化成整数</title>
      <link>http://blog.longpengfei.com/post/13-roman-to-integer-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Sat, 27 Jan 2018 15:09:37 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/13-roman-to-integer-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
Difficulty: Easy
这道题是把罗马数字转化成整数,和12. Integer to Roman 整数转罗马数字正好反着.关于罗马数字的简单介绍可以回看12. Integer to Roman 整数转罗马数字.
这道题明确告诉我们输入的是罗马数字,所有不需要验证是否为罗马数字.下面只需要考虑
 如果当前数字是最后一个数字,或之后的数字比它小的话,则加上当前的数字.举个反例CD-400,D比C大,所以先减去C(100)再加上D(500),就得到结果400 其他情况则减去这个数字  #include &amp;lt;unordered_map&amp;gt; using namespace std; class Solution { public: int romanToInt(string s) { int res = 0; unordered_map&amp;lt;char, int&amp;gt; m{{&#39;I&#39;,1},{&#39;V&#39;,5},{&#39;X&#39;,10},{&#39;L&#39;,50},{&#39;C&#39;,100},{&#39;D&#39;,500},{&#39;M&#39;,1000}}; for (int i = 0; i &amp;lt; s.size(); i++) { int val = m[s[i]]; //m[s[i+1]]不需要考虑越界,因为有&#39;\0&#39; m[&#39;\0&#39;]=0 if (i == s.</description>
    </item>
    
    <item>
      <title>目录</title>
      <link>http://blog.longpengfei.com/post/leetcode-catalog/</link>
      <pubDate>Fri, 26 Jan 2018 18:24:41 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/leetcode-catalog/</guid>
      <description>Number
题号 Problems
题目 Difficulty
难度 Topics(Tags)
标签     1 Two Sum 两数之和等于一个输入的数 Easy Array, Hash Table   2 Add TwoNumbers 两个链表相加 Medium Linked List, Math   3 Longest Substring Without Repeating Characters 子字符串的最大不重复长度 Medium Hash Table, Two Pointers, String   4 Median of Two Sorted Arrays两个数组的中位数 Hard Array, Binary Search, Divide and Conquer   5 Longest Palindromic Substring 最长回文子字符串 Medium String, Dynamic Programming   6 ZigZag Conversion 之子形转换字符串 Medium String   7 Reverse Integer 翻转整数 Easy Math   8 String to Integer Atoi 把字符串转换成整数 Medium String, Math   9 Palindrome Number 验证回文数字 Easy Math   10 Regular Expression Matching 正则表达式匹配 Hard String, Dynamic Programming, Backtracking   11 Container With Most Water 装最多水的容器 Medium Array, Hash Table   12 Integer to Roman 整数转罗马数字 Medium String, Math   13 Roman to Integer 罗马数字转化成整数 Easy String, Math   14 Longest Common Prefix 最长共同前缀 Easy String   15 3Sum 三数之和 Medium Array, Two Pointers   16 3Sum Closest 最近三数之和 Medium Array, Two Pointers   17 Letter Combinations of a Phone Number 电话号码的字母组合 Medium String, Backtracking, DFS   18 4Sum 四数之和 Medium Array, Hash Table, Two Pointers   19 Remove Nth Node From End of List 移除链表倒数第N个节点 Medium Linked List, Two Pointers   20 Valid Parentheses 验证括号 Easy String, Stack   21 Merge Two Sorted Lists 混合插入有序链表 Easy Linked List   22 Generate Parentheses 生成括号 Medium String, Backtracking, DFS   23 Merge K Sorted Lists 合并k个有序链表 Hard Linked List, Divide and Conquer, Heap   24 Swap Nodes in Pairs 成对交换节点 Medium Linked List   25 Reverse Nodes in K Group 每k个一组翻转链表 Hard Linked List   26 Remove Duplicates From Sorted Array 有序数组中去除重复项 Easy Array, Two Pointers   27 Remove Element 移除元素 Easy Array, Two Pointers   28 Implement strStr() 实现strStr()函数 Easy Two Pointers, String   29 Divide Two Integers 两数相除 Medium Math , Binary Search   30 Substring With Concatenation of All Words 串联所有单词的子串 Hard Hash Table, Two Pointers, String   31 Next Permutation 下一个排列 Medium Array   32 Longest Valid Parentheses 最长有效括号 Hard String, Dynamic Programming   33 Search in Rotated Sorted Array 在旋转有序数组中搜索 Medium Array, Binary Search   34 Search for a Range 搜索一个范围 Medium Array, Binary Search   35 Search Insert Position 搜索插入位置 Easy Array, Binary Search   36 Valid Sudoku 验证数独 Medium Hash Table   37 Sudoku Solver 求数独的一个解 Hard Backtracking,Hash Table   38 Count and Say 计数和读法 Easy String   39 Combination Sum 组合之和 Medium Array, Backtracking   40 Combination Sum II 组合之和之二 Medium Array, Backtracking   41 First Missing Positive 首个缺失的正数 Hard Array   42 Trapping Rain Water 收集雨水 Hard Array, Two Pointers, Stack   43 Multiply Strings 字符串相乘 Medium String, Math   44 Wildcard Matching 通配符匹配 Hard Math, Dynamic Programming, Backtracking, Greedy   45 Jump Game 2 跳跃游戏2 Hard Array, Greedy   46 Permutations 全排列 Medium Backtracking   47 PermutationsII 全排列2 Medium Backtracking   48 Rotate Image 旋转图像 Medium Array   49 Group Anagrams 群组错位词 Medium String,Hash Table   50 Pow(x, n) 求x的n次方 Medium Math, Binary Search   51 N Queens N皇后问题 Hard Backtracking   146 LRU Cache 最近最少使用置换缓存器 Hard Design</description>
    </item>
    
    <item>
      <title>12. Integer to Roman 整数转罗马数字</title>
      <link>http://blog.longpengfei.com/post/12-integer-to-roman-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 26 Jan 2018 16:42:56 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/12-integer-to-roman-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>Given an integer, convert it to a roman numeral.
Input is guaranteed to be within the range from 1 to 3999.
Difficulty: Medium
罗马字符:	I	V	X	L	C	D	M 阿拉伯数字:	1	5	10	50	100	500	1000 1~9 : I, II, III, IV, V, VI, VII, VIII, IX 10~90 : X, XX, XXX, XL, L, LX, LXX, LXXX, XC 100~900: C, CC, CCC, CD, D, DC, DCC, DCCC, CM 1000~3000: M, MM, MMM  例如: 整数1437的罗马数字为MCDXXXVII.</description>
    </item>
    
    <item>
      <title>11. Container With Most Water 装最多水的容器</title>
      <link>http://blog.longpengfei.com/post/11-container-with-most-water-%E8%A3%85%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 26 Jan 2018 14:14:50 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/11-container-with-most-water-%E8%A3%85%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.
Difficulty: Medium</description>
    </item>
    
    <item>
      <title>10. Regular Expression Matching 正则表达式匹配</title>
      <link>http://blog.longpengfei.com/post/10-regular-expression-matching-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 24 Jan 2018 18:51:58 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/10-regular-expression-matching-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>Implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.
&#39;.&#39; Matches any single character. &#39;*&#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char *s, const char *p) Some examples: isMatch(&amp;quot;aa&amp;quot;,&amp;quot;a&amp;quot;) → false isMatch(&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;) → true isMatch(&amp;quot;aaa&amp;quot;,&amp;quot;aa&amp;quot;) → false isMatch(&amp;quot;aa&amp;quot;, &amp;quot;a*&amp;quot;) → true isMatch(&amp;quot;aa&amp;quot;, &amp;quot;.*&amp;quot;) → true isMatch(&amp;quot;ab&amp;quot;, &amp;quot;.*&amp;quot;) → true isMatch(&amp;quot;aab&amp;quot;, &amp;quot;c*a*b&amp;quot;) → true  Difficulty: Hard</description>
    </item>
    
    <item>
      <title>9. Palindrome Number 验证回文数字</title>
      <link>http://blog.longpengfei.com/post/9-palindrome-number-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 24 Jan 2018 17:04:38 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/9-palindrome-number-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/</guid>
      <description>Determine whether an integer is a palindrome. Do this without extra space.
Some hints: Could negative integers be palindromes? (ie, -1)
If you are thinking of converting the integer to string, note the restriction of using extra space.
You could also try reversing an integer. However, if you have solved the problem &amp;ldquo;Reverse Integer&amp;rdquo;, you know that the reversed integer might overflow. How would you handle such case?
There is a more generic way of solving this problem.</description>
    </item>
    
    <item>
      <title>8 String to Integer Atoi 把字符串转换成整数</title>
      <link>http://blog.longpengfei.com/post/8-string-to-integer-atoi-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 24 Jan 2018 12:40:36 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/8-string-to-integer-atoi-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
Difficulty: Medium
把字符串转换成整数,和剑指offer 49题相似,不过这里的要求比较多,实现atoi
 判断开头是否有空格 判断开头是否有 &#39;+&#39;,&#39;-&#39; 如果遇到非法字符返回已有的结果 如果超过边界,返回边界值  class Solution { public: int myAtoi(string str) { int len = str.</description>
    </item>
    
    <item>
      <title>7 Reverse Integer 翻转整数</title>
      <link>http://blog.longpengfei.com/post/7-reverse-integer-%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 24 Jan 2018 10:40:15 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/7-reverse-integer-%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>Given a 32-bit signed integer, reverse digits of an integer.
Example 1:
Input: 123 Output: 321  Example 2:
Input: -123 Output: -321  Example 3:
Input: 120 Output: 21  Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
分析 Difficulty: Easy</description>
    </item>
    
    <item>
      <title>6 ZigZag Conversion 之子形转换字符串</title>
      <link>http://blog.longpengfei.com/post/6-zigzag-conversion-%E4%B9%8B%E5%AD%90%E5%BD%A2%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 23 Jan 2018 17:43:43 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/6-zigzag-conversion-%E4%B9%8B%E5%AD%90%E5%BD%A2%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
P A H N A P L S I I G Y I R  And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot; Write the code that will take a string and make this conversion given a number of rows:</description>
    </item>
    
    <item>
      <title>Manacher 马拉车算法</title>
      <link>http://blog.longpengfei.com/post/manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 18 Jan 2018 12:01:24 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</guid>
      <description>Manacher马拉车算法是解决回文子串长度的算法,可以是时间复杂度为O(n).回文字符串就是正着读,反着读都一样的字符串.aba,abba.
由于回文串的长度可奇可偶, 为避免奇偶判断,Manacher的第一步预处理为在字符串的首尾和每个字符的间隙中都插入#,如#a#b#a#,#a#b#b#a#,这样转换后的字符串t恒为奇数.接下里加入一个辅助数组p,其中p[i]表示以t[i]字符为中心的回文子串的半径,若p[i]=1,那该回文子串就是t[i]本身.
#1#2#2#1#2#2# 1212521612321  由于第一个和最后一个字符都是#号,并且也需要搜索回文,为了防止越界,还需要在首尾加上非#号字符,实际操作时,我们只需要给开头加上非#号字符,结尾不用加的原因是字符串的结尾标识为\0,等于默认加过了.从上面可以看出p[i]-1正好为元字符串在i处的回文子串的长度.下面只要求出p数组中的最大值就行.新增两个辅助变量mx和id,其中id为最大回文子串的中心的位置,mx是回文串能延伸到的最右端的位置,这个算法的最核心的一行:
p[i] = mx&amp;gt;i ? min(p[2*id-1],mx-i) : 1;  如图j是i关于id的对称点.
  当mx&amp;gt;i时候p[i]=min(p[2*id-i],mx-i)=min(p[j],mx-i),为什么呢?
此时还需要分开讨论:
当mx-i&amp;gt;p[j]如上图,红色距离大于黄色距离.以j为中心的回文子串包含在id为中心的回文子串中.i和j对称,所以i为中心的回文子串也在id为中心的回文子串中.所以有p[i]=p[j].
当mx-i&amp;gt;p[j]的时候,j为中心的回文子串不一定全部包含在id为中心的回文子串中,基于对称性可知i为中心的回文子串最右端可能超出mx处,就是p[i]&amp;gt;=mx-i,如下图,绿色的部分是相同的.至于p[i]具体能在mx右边延伸到多远,就只能循环向右边扩展边比较，直至不为子回文串。
  对于mx&amp;lt;=i的情况,i在mx的右边未知区域.无法对p[i]做更多的假设,只能p[i]=1,然后去虚幻向右比较扩展。
参考代码如下:
#include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; using namespace std; string Manacher(string s) { //insert &#39;#&#39; string t = &amp;quot;$#&amp;quot;; for (int i = 0;i&amp;lt;s.size();++i){ t += s[i]; t += &amp;quot;#&amp;quot;; } //process t vector&amp;lt;int&amp;gt; p(t.size(),0); int mx = 0,id = 0,resLen = 0,resCenter = 0; for (int i = 1; i &amp;lt; t.</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring 最长回文子字符串</title>
      <link>http://blog.longpengfei.com/post/longest-palindromic-substring-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 15 Jan 2018 17:03:21 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/longest-palindromic-substring-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
Difficulty:Medium
Example:
Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer.  Example:
Input: &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot;  这道题参考Grandyang,他博客里有全套leetcode讲解.
求最长回文串,回文串就是正着读反着读都一样的字符串.下面的解法是以一个字符为中心向两边扩散并比较 
解法1: O(n^2) class Solution { public: public: string longestPalindrome(string s) { int startIdx = 0, left = 0, right = 0, len = 0; for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays两个数组的中位数</title>
      <link>http://blog.longpengfei.com/post/median-of-two-sorted-arrays%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sat, 13 Jan 2018 15:45:29 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/median-of-two-sorted-arrays%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
Example1:
nums1 = [1, 3] nums2 = [2] The median is 2.0  Example2
nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5  分析 解法一:
思路来自Very concise O(log(min(M,N))) iterative solution with detailed explanation 看到O(log (m+n))一般来说就是分治法或是二分搜索,一个数组(长度为N)在中间切一刀,那它左边的索引L为(N-1)/2,右边的索引R为N/2.</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters 子字符串的最大不重复长度</title>
      <link>http://blog.longpengfei.com/post/longest-substring-without-repeating-characters-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Fri, 12 Jan 2018 11:41:10 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/longest-substring-without-repeating-characters-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%95%BF%E5%BA%A6/</guid>
      <description>Given a string, find the length of the longest substring without repeating characters.
Examples:
Given &amp;quot;abcabcbb&amp;quot;, the answer is &amp;quot;abc&amp;quot;, which the length is 3.
Given &amp;quot;bbbbb&amp;quot;, the answer is &amp;quot;b&amp;quot;, with the length of 1.
Given &amp;quot;pwwkew&amp;quot;, the answer is &amp;quot;wke&amp;quot;, with the length of 3. Note that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.
滑动窗口问题,比如abcabcbb,滑动到abca的时候需要丢弃第一个a变成bca,继续向右滑动,每次滑动都要检查有没有重复.感觉涉及到最大,最多的问题都可以试着网哈希表上靠. 
class Solution { public: int lengthOfLongestSubstring(string s) { int size = s.</description>
    </item>
    
    <item>
      <title>Add TwoNumbers 两个链表相加</title>
      <link>http://blog.longpengfei.com/post/add-twonumbers-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Wed, 10 Jan 2018 21:39:18 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/add-twonumbers-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</guid>
      <description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>Two Sum 两数之和等于一个输入的数</title>
      <link>http://blog.longpengfei.com/post/two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0/</link>
      <pubDate>Wed, 10 Jan 2018 19:21:32 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/two-sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E7%AD%89%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  要返回数组中两个数的索引,这两个数的和等于输入的数.最简单的两层for循环可定不能满足要求.考虑优化时间复杂度,可尝试牺牲时间复杂度. stack?queue?vector?还是hash_map.stack,queue,vector查找都是O(n),hash_map为O(1).接下来尝试用hash_map解决问题. 
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;res; if(nums.</description>
    </item>
    
    <item>
      <title>刷一哈剑指Offer</title>
      <link>http://blog.longpengfei.com/post/atoffer/</link>
      <pubDate>Mon, 08 Jan 2018 21:18:56 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/atoffer/</guid>
      <description>这是前一阵用c++刷过的剑指offer题,做个记录.我的github上有每个题的Xcode项目,方便调试.
目录  1. 二维数组中的查找 2. 字符串中的空格替换 3. 从尾到头打印链表 4. 重建二叉树 5. 两个栈实现队列 6. 旋转数组的最小数字 7. 斐波那契数列 8. 跳台阶 9. 变态跳台阶 10. 矩形覆盖 位运算tip 11. 二进制中1的个数 12. 数值的整数次方 13. 调整数组顺序使奇数位于偶数前面 14. 链表中倒数第k个结点 15. 反转链表 16. 合并两个排序的列表 17. 树的子结构 18. 二叉树的镜像 19. 顺时针打印矩阵 20. 包含min函数的栈 21. 栈的压入、弹出序列 22. 从上到下打印二叉树 23. 二叉搜索树的后序遍历序列 24. 二叉树中和为某一值的路径 25. 复杂链表的复制 二叉树的前中后序遍历 26. 二叉搜索树与双向链表 27. 字符串的排列 28. 数组中出现次数超过一半的数字 红黑树,快排,堆排,合并排序 29. 最小的K个数 30. 连续子数组的最大和 31. 整数中1出现的次数(从1到n整数中1出现的次数) 32. 把数组排成最小的数 33.</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>http://blog.longpengfei.com/contact/</link>
      <pubDate>Sun, 07 Jan 2018 16:47:06 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/contact/</guid>
      <description>联系方式 :
 QQ : 466142249 Mail : long.pf@outlook.com Mail : long.pf@hotmail.com</description>
    </item>
    
    <item>
      <title>Python笔记</title>
      <link>http://blog.longpengfei.com/post/python-note/</link>
      <pubDate>Sat, 08 Jul 2017 20:03:17 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/python-note/</guid>
      <description>Python学习笔记 这里是我学习廖雪峰python做的笔记.比较长,主要方便回看
关键目录  安装 sublime开发python py基础 list和tuple dict和set 函数 函数的参数 递归函数 高级特性 切片,迭代,列表生成,生成器 函数式编程 map/reduce filter,sort 返回函数,闭包,装饰器,匿名函数 偏函数 模块 面向对象编程 获取对象信息 实例属性和类属性 面向对象高级编程 slots限制class绑定的属性 @property 多重继承 定制类 使用元类 错误,调试和测试 IO编程 进程和线程 正则表达式 常用内建模块 常用第三方模块 virtualenv 图形界面 网络编程 电子邮件  正文 第一个py程序 安装 安装

sublime开发python python3 build  1 type -a python3查看pythons路径 2 Sublime-&amp;gt;Tools-&amp;gt;build system-&amp;gt;new build system 3 修改为
{ &amp;quot;cmd&amp;quot;: [&amp;quot;python3路径&amp;quot;,&amp;quot;-u&amp;quot;,&amp;quot;$file&amp;quot;], }  4 保存为Python3.sublime-build
  macOS用Terminal打开sublime ln -s &amp;quot;/Applications/Sublime Text.</description>
    </item>
    
    <item>
      <title>Swift实现可选协议</title>
      <link>http://blog.longpengfei.com/post/swift-optional-protocol/</link>
      <pubDate>Sun, 12 Mar 2017 20:40:50 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/swift-optional-protocol/</guid>
      <description> Swift实现可选协议 定义
@objc protocol FTMagicMoveTransionFromProtocol { @objc optional func captureView() -&amp;gt; UIView? }  实现
//parent class FTViewController: UIViewController, FTMagicMoveTransionFromProtocol{ func captureView() -&amp;gt; UIView? { return nil } }  //child class FTHomeViewController: FTViewController{ override func captureView() -&amp;gt; UIView { return (selectedCell?.thumbImageView)! } }  </description>
    </item>
    
    <item>
      <title>Swift调用objective-c的framework(非pod)需要注意的</title>
      <link>http://blog.longpengfei.com/post/oc-framework-4-swift/</link>
      <pubDate>Wed, 08 Mar 2017 20:40:50 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/oc-framework-4-swift/</guid>
      <description>swift调用objective-c的framework(非pod)需要注意的  1. 创建AppName-Bridging-Header,并#import&amp;lt;&amp;gt;相关文件 2. General -&amp;gt; Embedded Binaried添加 3. Build Setting -&amp;gt; Swift Compiler-General -&amp;gt; Objective-C Briding Header 添加header的path,如:FaceTube/FaceTube-Bridging-Header.h 4. Link Binary With Libraries 添加相关framework  再就是可以试试把生成framework的项目拖到自己项目中运行生成framework例如这样
这样之后如果还报错 在link Binary With Libraries中添加libc++.tbd应该可以搞定</description>
    </item>
    
    <item>
      <title>UIKit性能优化</title>
      <link>http://blog.longpengfei.com/post/uikit-performance-optimization/</link>
      <pubDate>Thu, 12 Jan 2017 05:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/uikit-performance-optimization/</guid>
      <description>Instrument (command+I) 原文地址
Core Animation : Color Blended Layers :
检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。 对于UIImageView来说，不仅它自身需要是不透明的，它的图片也不能含有alpha通道. PS：如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个sublayer，如果有好的解决办法欢迎告诉我。
Color Hits Green and Misses Red :
表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好. 光栅化的核心在于缓存的思想。
layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去
光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化
// label.layer.shouldRasterize = true
Color Copied Images :
像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。 “Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。 当我们打开JPEG格式的图片时，CPU会进行一系列运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。 CPU主要处理两件事：
把图片从PNG或JPEG等格式中解压出来，得到像素数据 如果GPU不支持这种颜色各式，CPU需要进行格式转换
Color Misaligned Images :
表示如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色 图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。
Color Offscreen-Rendered Yellow :
离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。 会把需要离屏渲染的地方标记为黄色，大部分情况下我们需要尽可能避免黄色的出现。离屏渲染可能会自动触发，也可以手动触发。以下情况可能会导致触发离屏渲染： 重写drawRect方法 有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask layer.shouldRasterize = true
前两者会自动触发离屏渲染，第三种方法是手动开启离屏渲染
设置阴影的时候要指定path 要不会离屏渲染
设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来：
Color Compositing Fast-Path Blue:</description>
    </item>
    
    <item>
      <title>哈希表简记</title>
      <link>http://blog.longpengfei.com/post/understanding-hashtable/</link>
      <pubDate>Wed, 11 Jan 2017 05:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/understanding-hashtable/</guid>
      <description>哈希表 散列表(哈希表),是根据键而直接访问在内存存储位置的数据结构.也就是说,他通过计算一个关于键值的函数,将所需查询的数据映射到表中一个位置来访问记录,这加快了查找速度,这个映射函数称作散列函数,存放的数组称作散列表.
一个通俗的例子是,通讯录,通过字母w来查找&amp;rsquo;王&amp;rsquo;,这里用人名作关键字.
基本概念  若关键字为k,则其值存放在f(k)的存储位置上.由此,不需要比较便可直接取得所查记录.f为散列函数,按这个思想简历的表为散列表.
 对不同搞得关键字可能得到同一散列地址,即k1!=k2,f(k1)=f(k2),这种现象叫冲突,k1,k2称为同义词.综上所述根据散列函数f和处理冲突的方法将一组关键字映射到一个有限的连续的地址集(区间)上,并以关键字在地址集中的&amp;rsquo;像&amp;rsquo;作为记录在表中的存储位置,这种表便称为散列表,这一映射过程称为散列造表或散列,所得的存储位置称散列地址.
 若对于关键字集合中的任一个关键字,经散列函数映像到地址结合中任何一个地址的概率是相等的,则称此类散列函数为均匀散列函数,这就是使关键字经过散列函数得到一个&amp;rsquo;随机的地址&amp;rsquo;,从而减少冲突.
  构造散列函数 散列函数能使一个数据序列的访问过程更加迅速有效,通过散列函数,数据元素将被更快定位.
 1. 直接定址法 : 取关键字或关键字的某个线性函数值为散列地址.即hash(k)=a*k+b,其中ab为常数.这种散列函数叫做自身函数. 2. 数字分析法 : 假设关键字是以r为基的数,并且哈希表中可能出现的关键字都是事先知道的,则可取关键字的若干数位组成哈希地址. 3. 平方取中法 : 取关键字平方后的中间几位为哈希地址.一个数平方后的中间几位数和数的每一位都相关,由此使随机分布的关键字得到的哈希地址也是随机的.取得位数由表长决定 4. 折叠法 : 将关键字分割成位数相同的几部分(最后一部分的位数可以不同),然后取这几部分的叠加和(舍去进位)最为哈希地址 5. 随机数法 6. 除留余数法 :取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即hash(k)=k mod p, p&amp;lt;=m.不仅可以对关键字直接取模,也可以在折叠法,平方取中法等运算之后取模.对p的选择很重要,一般取素数或m,若p选择不好,容易产生冲突  处理冲突 为了知道冲突产生的相同散列函数地址所对应的关键字,必须选用另外的散列函数,或者对冲突结果进行处理.而不发生冲突的可能性是非常之小的,所以通常对冲突进行处理.
 开放定址法(open addressing) : hashi = (hash(key) + di) mod m ,其中hash(key)为散列函数,m为散列表长,di为增量序列,i为已发生冲突次数.增量序列可有下列取法:  di = 1,2,3&amp;hellip;(m-1)称为线性探测;即 di = i,或者为其他线性函数.相当于诸葛探测粗放地址的表,知道查到一个空单元,把散列地址存放在该空单元.
di = &amp;plusmn;1&amp;sup2;,&amp;plusmn;2&amp;sup2;,&amp;plusmn;3&amp;sup2;&amp;hellip;&amp;plusmn;k&amp;sup2;,(k&amp;le;m/2),称为平方探测,相对线性探测,相对于发生冲突时探测间隔di = i&amp;sup2;个单元的位置是否为空,如果为空,降低至存放进去
di = 伪随机数,称为 伪随机探测</description>
    </item>
    
    <item>
      <title>AspectsCocoa</title>
      <link>http://blog.longpengfei.com/post/aspectscocoa/</link>
      <pubDate>Tue, 10 Jan 2017 01:49:52 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/aspectscocoa/</guid>
      <description>前言 : 本来是想写一个简易高效的rac, 不过在写信号传递的时候没找到好的解决方法,又不想像rac那样在传递的时候不断创建信号,因为要高效嘛.如果大家有啥好的方法麻烦告诉我下QQ466142249,如果发现什么错误,或者某个部分可以有更好的实现也麻烦告诉我下,哈哈哈哈.这里的全部代码在github的这里.
如何使用AspectsCocoa? 添加 :
 [self.label addObserver:self forSelector:@selector(setText:) withBlock:^(AOPObserverInfo *info,NSString *text){ NSLog(@&amp;quot;text = %@&amp;quot;,text); }]; [self.label addObserver:self forSelector:@selector(drawTextInRect:) withBlock:^(AOPObserverInfo *info,NSValue *rectValue){ NSLog(@&amp;quot;rectValue = %@&amp;quot;,rectValue); }];  移除 :
[self.label removeObserver:self forSelector:@selector(setText:)];
or
[self.label removeObserver:self];
详细可以参看demo 
大概思路 其实和KVO的原理有点相似,衍生出来一个中间类,重写setter方法做到键值监听.不过这里不是只有setter方法还有其他普通的方法.再就是普通方法的变化参数需要好好处理下.
 1 . 判断该类是否有这个监听方法 (这里我就直接取这个方法的类方法和实例方法,如果都不存在,则抛出异常) 2 . 判断是否生成过中间类,没生成则生成一个 3 . 查看中间类是否有要监听的方法,没有添加方法 (有关于普通方法的变参问题,我这里是用va_list来处理的) 4 . 储存监听信息和回调  具体实现  1 . 判断该类是否有这个监听方法   Method method = class_getInstanceMethod([self class], selector); if (!</description>
    </item>
    
    <item>
      <title>Git Flow 常用命令</title>
      <link>http://blog.longpengfei.com/post/git-flow-command/</link>
      <pubDate>Fri, 30 Dec 2016 14:52:55 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/git-flow-command/</guid>
      <description>git flow feature start branchname
 开始一个featuer分支,feature分支的名字一般为功能+人名,如capture.xiaoming  git flow feature publish branchname
 将一个featuer分支推到远程,多人开发  git checkout -b feature/branchname origin/feature/branchname * 将远程的featuer分支下到本地开发
git flow feature finish branchname * 合并至本地develop * 删除任务分支
git pull --rebase
git flow release start v6.6.3 * 开始release分支
git flow release publish v6.6.3
git flow release finish v6.6.3 * 合并release分支到master * 在master上打上tag * 合并release到develop * 删除release
git flow hotfix start v6.6.4 * 开始修复分支
git flow hotfix finish v6.</description>
    </item>
    
    <item>
      <title>Git 常用命令简记</title>
      <link>http://blog.longpengfei.com/post/git-command/</link>
      <pubDate>Fri, 30 Dec 2016 14:51:55 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/git-command/</guid>
      <description>前:HEAD关键字是指当前分支的最新一次提交,就是版本库中该分支上的最新版本
git init git init 初始化一个repo,创建一个.git文件夹
git clone git clone url newname nenamew 可以不要
git log git log --oneline 每条log显示一行
git log --oneline --graph 图形化
git log branchname 指定分支log
git log --oneline branch1 ^branch2 在分支1,不在分支2,^为排除
git log --author=[author name]指定作者
git log --grep=keywords筛选commit信息
git log --grep=keywords --author=authorname 是OR的关系,如果想为AND则添加&amp;ndash;all-match
git reflog 对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化 当git reflog 不指定引用的时候,默认列出HEAD的reflog git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD,分支的reflog文件都放在.git/logs/refs目录下的子目录中.
git reflog 可以看到reset的commit
git add git add file
git add . 递归添加工作区的修改到暂缓区
git commit git commit -m &amp;quot;message&amp;quot;</description>
    </item>
    
    <item>
      <title>Swift基础简单笔记</title>
      <link>http://blog.longpengfei.com/post/swift-simple-notes/</link>
      <pubDate>Wed, 30 Nov 2016 14:51:55 +0800</pubDate>
      
      <guid>http://blog.longpengfei.com/post/swift-simple-notes/</guid>
      <description>Swift基础简单笔记 菜鸟Swift
目录  1. 渣渣 2. 函数 3. 闭包 4. 枚举 5. 结构体 6. 类 7. 属性 8. 方法 9. 下标脚本 10. 继承 11. 构造,析构,可选链 12. 自动引用计数 13. 类型转换 14. 扩展 15. 协议 16. 泛型 17. 访问控制  
var aa:Float aa = 3.14 print(aa)  输出 var name = &amp;quot;666&amp;quot; var site = &amp;quot;777&amp;quot; print(&amp;quot;\(name)dddd\(site)&amp;quot;)  16进制小数 : 0xFp2 表示 15 ⨉ 2^2，也就是 60；同样，0xFp-2 表示 15 ⨉ 2^-2，也就是 3.</description>
    </item>
    
  </channel>
</rss>